{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Software Engineering Knowledge Base","text":"<p>Welcome to my personal knowledge base as a software engineer. This site serves as a comprehensive collection of my learning journey, notes, and resources across various aspects of software engineering.</p>"},{"location":"#purpose","title":"\ud83c\udfaf Purpose","text":"<p>This knowledge base aims to:</p> <ul> <li>Document and share knowledge about software engineering concepts</li> <li>Provide a structured learning path for various topics</li> <li>Serve as a reference for system design and development practices</li> <li>Foster continuous learning and improvement</li> </ul>"},{"location":"#topics-covered","title":"\ud83d\udcda Topics Covered","text":""},{"location":"#core-areas","title":"Core Areas","text":"<ul> <li> <p>System Design</p> <ul> <li>Architecture patterns and principles</li> <li>Scalability and performance optimization</li> <li>Distributed systems and microservices</li> <li>Reliability and fault tolerance</li> </ul> </li> <li> <p>Backend Development</p> <ul> <li>Server-side programming</li> <li>API design and implementation</li> <li>Database systems and optimization</li> <li>Security and authentication</li> </ul> </li> <li> <p>Data Structures &amp; Algorithms</p> <ul> <li>Core computer science concepts</li> <li>Problem-solving techniques</li> <li>Algorithm analysis and optimization</li> <li>Common patterns and implementations</li> </ul> </li> <li> <p>Frontend Development</p> <ul> <li>Web technologies and frameworks</li> <li>UI/UX principles and best practices</li> <li>Performance optimization</li> <li>Modern JavaScript and TypeScript</li> </ul> </li> </ul>"},{"location":"#system-design-knowledge-base","title":"System Design Knowledge Base","text":"<p>A comprehensive collection of system design concepts, patterns, and best practices.</p>"},{"location":"#fundamentals","title":"Fundamentals","text":"<p>Core system design concepts and principles:</p> <ul> <li>Client-Server Architecture - Understanding the client-server model, application layers, and deployment patterns</li> <li>Server Infrastructure - Server types, deployment models, and infrastructure components</li> <li>Networking &amp; Communication - Network models, protocols, and performance metrics</li> <li>API Development &amp; Management - API architecture, communication mechanisms, and reliability patterns</li> <li>Database &amp; Storage - Database types, data partitioning, and storage solutions</li> <li>Scalability &amp; Performance - Scaling strategies, performance optimization, and load balancing</li> <li>Reliability &amp; Consistency - Consistency models, reliability patterns, and fault tolerance</li> <li>Software Architecture &amp; Design - Architecture patterns, microservices design, and software design approaches</li> </ul>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"#how-to-use-this-knowledge-base","title":"How to Use This Knowledge Base","text":"<ol> <li> <p>Navigation</p> <ul> <li>Use the left sidebar to explore different topics</li> <li>Follow the hierarchical structure to dive deeper into specific areas</li> <li>Use the search function to find specific information quickly</li> </ul> </li> <li> <p>Learning Path</p> <ul> <li>Start with fundamentals before moving to advanced topics</li> <li>Follow the suggested reading order within each section</li> <li>Practice concepts through provided examples and case studies</li> </ul> </li> <li> <p>Best Practices</p> <ul> <li>Take notes and implement concepts in your projects</li> <li>Refer back to relevant sections when needed</li> <li>Stay updated with new content and improvements</li> </ul> </li> </ol>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>This is a personal knowledge base, but I welcome feedback and suggestions. Feel free to reach out if you notice any inaccuracies or have recommendations for improvement.</p> <ol> <li> <p>Content Improvements</p> <ul> <li>Submit issues for topics you'd like to see covered</li> <li>Suggest improvements to existing content</li> <li>Contribute new content through pull requests</li> </ul> </li> <li> <p>Feedback</p> <ul> <li>Report any inaccuracies or outdated information</li> <li>Suggest better examples or explanations</li> <li>Share your learning experiences</li> </ul> </li> </ol>"},{"location":"#technical-details","title":"\ud83d\udee0\ufe0f Technical Details","text":"<p>This documentation is built with:</p> <ul> <li>Material for MkDocs - A modern documentation site generator</li> <li>Mermaid - For creating diagrams and flowcharts</li> <li>GitHub Pages - For hosting the documentation</li> </ul>"},{"location":"System%20Design%20Fundamental/","title":"System Design Fundamentals","text":""},{"location":"System%20Design%20Fundamental/#client-server-architecture","title":"Client-Server Architecture","text":"<p>A computing model where tasks are distributed between clients (requesters) and servers (providers of resources/services).</p>"},{"location":"System%20Design%20Fundamental/#core-components","title":"Core Components","text":""},{"location":"System%20Design%20Fundamental/#client","title":"Client","text":"<p>End-user (client) devices or applications that communicates with consumer applications to make requests to servers.</p> <p>Examples</p> <ul> <li>Client devices: Web browser, phone, computer</li> <li>Consumer apps: Web application, mobile application</li> </ul>"},{"location":"System%20Design%20Fundamental/#server","title":"Server","text":"<p>Dedicated computers or software that provides services, resources or data to clients over a network to fulfill requests.</p>"},{"location":"System%20Design%20Fundamental/#application-layers","title":"Application Layers","text":""},{"location":"System%20Design%20Fundamental/#frontend","title":"Frontend","text":"<p>Web servers that serve static files (HTML, CSS, JavaScript), routes requests to appropriate backend servers, often acts as the entry point for client application.</p> <p>Important Note</p> <p>All frontend servers are web servers, but not all web servers that serve static files are considered frontend servers (Ex: CDN, Static File Servers).</p> <p>Examples</p> <ul> <li>Node.js with Express: Often used to create custom frontend servers that serve React/Angular/Vue applications</li> <li>Nginx as a frontend proxy: Configured specifically to route and cache frontend resources</li> </ul>"},{"location":"System%20Design%20Fundamental/#backend","title":"Backend","text":"<p>Application servers that host server-side applications that process business logic, handle data operations, and interact with databases and other services.</p> <p>Examples</p> <ul> <li>Application servers running Node.js, Python, Java, .NET, etc.</li> </ul>"},{"location":"System%20Design%20Fundamental/#browserfrontend-app","title":"Browser/Frontend App","text":"<p>A client-side application (1) running on the user's device that provides the interface users interact with directly in their browser.</p> <ol> <li>client-side application: A collection of static files (HTML, CSS, and JavaScript)</li> </ol> <p>Examples</p> <ul> <li>Examples: Web apps developed using frontend frameworks like React, Vue.js, Angular</li> </ul>"},{"location":"System%20Design%20Fundamental/#backend-app","title":"Backend App","text":"<p>Server-side applications (typically stateless services) that run on backend servers, implement business logic and data processing functionalities, and expose APIs for clients to consume.</p> <p>Examples</p> <ul> <li>Applications built with ASP.NET Core, Django, Node.js</li> </ul>"},{"location":"System%20Design%20Fundamental/#application-types","title":"Application Types","text":"Traditional Web ApplicationSingle Page Application (SPA)Progressive Web Application (PWA) <p>Web applications where pages are fully rendered on the server before being sent to the client.</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant B as Browser\n    participant S as Server\n\n    U-&gt;&gt;B: Initial request\n    B-&gt;&gt;S: GET /page\n    S-&gt;&gt;B: Generate and return complete HTML\n    B-&gt;&gt;U: Display page\n\n    U-&gt;&gt;B: Click link/submit form\n    B-&gt;&gt;S: GET/POST new request\n    S-&gt;&gt;B: Generate and return new complete HTML\n    B-&gt;&gt;U: Display new page (full reload)</code></pre> <p>Web applications that load a single HTML page and dynamically update content without full page reloads.</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant B as Browser\n    participant S as Server\n\n    U-&gt;&gt;B: Initial request\n    B-&gt;&gt;S: GET index.html\n    S-&gt;&gt;B: Return HTML, CSS, JavaScript\n    Note over B: SPA loads completely\n\n    U-&gt;&gt;B: Interact with page\n    B-&gt;&gt;B: Update DOM\n\n    U-&gt;&gt;B: Request new data\n    B-&gt;&gt;S: AJAX call to API\n    S-&gt;&gt;B: Return JSON data\n    B-&gt;&gt;B: Update view without page reload</code></pre> <p>Tip</p> <p>SPAs use AJAX and JavaScript to fetch data from servers and modify the current page without requiring full page reloads.</p> <p>Web applications that use modern web technologies to deliver app-like experiences to users.</p> <pre><code>flowchart LR\n    Client[Client] --&gt;|HTTP/HTTPS| SW[Service Worker]\n    SW --&gt;|Cache| CS[Cache Storage]\n    SW --&gt;|Sync| BS[Background Sync]\n    SW --&gt;|Push| PN[Push API]\n\n    Client --&gt;|Install| WM[Web Manifest]\n    WM --&gt;|Metadata| App[PWA]\n    App --&gt;|Offline| SW\n    App --&gt;|Responsive| Client</code></pre> <p>Key Features</p> <p>PWAs are responsive, work offline, can be installed on home screens, support push notifications, and combine the best features of web and mobile applications.</p>"},{"location":"System%20Design%20Fundamental/#deployment-architecture-patterns","title":"Deployment Architecture Patterns","text":"Single-Tier ArchitectureMulti-Tier ArchitectureContainerized Architecture <p>A deployment strategy where all application components (presentation, logic, data) run on a single server. All components share the same computing resources and system environment.</p> <pre><code>flowchart LR\n    subgraph \"Web server (IIS/Nginx)\"\n        UI[User Interface] --&gt; BL[Business Logic]\n        BL --&gt; DB[(Database)]\n    end\n    User((\"User/Browser\")) --&gt;|HTTP| UI</code></pre> <p>A deployment strategy that splits application components across multiple servers by deploying them into separate tiers for web servers, application servers, and database servers to improves scalability, enhances maintainability, and strengthens security.</p> <pre><code>flowchart LR\n    User((\"User/Browser\")) --&gt;|HTTP| LB[Load Balancer]\n\n    subgraph \"Presentation Tier\"\n        W1[Web Server 1]\n        W2[Web Server 2]\n    end\n\n    subgraph \"Application Tier\"\n        A1[App Server 1]\n        A2[App Server 2]\n    end\n\n    subgraph \"Data Tier\"\n        DB1[(Primary DB)]\n        DB2[(Replica DB)]\n    end\n\n    LB --&gt; W1\n    LB --&gt; W2\n    W1 --&gt;|API calls| A1\n    W1 --&gt;|API calls| A2\n    W2 --&gt;|API calls| A1\n    W2 --&gt;|API calls| A2\n    A1 --&gt;|SQL| DB1\n    A2 --&gt;|SQL| DB1\n    DB1 -.-&gt;|Replication| DB2</code></pre> <p>A deployment strategy using containerization (Docker, etc.) to package application components with their dependencies. This enables consistent deployment across different environments and works with orchestration platforms like Kubernetes.</p> <pre><code>flowchart TB\n    User((\"User/Browser\")) --&gt;|HTTP| API[API Gateway]\n\n    subgraph \"Kubernetes Cluster\"\n        subgraph \"Node 1\"\n            C1{{UI Container}}\n            C2{{Auth Container}}\n        end\n\n        subgraph \"Node 2\"\n            C3{{Payment Container}}\n            C4{{Product Container}}\n        end\n\n        subgraph \"Node 3\"\n            C5{{Notification Container}}\n            C6{{Analytics Container}}\n        end\n\n        subgraph \"Persistent Storage\"\n            DB1[(Auth DB)]\n            DB2[(Product DB)]\n            DB3[(Payment DB)]\n        end\n    end\n\n    API --&gt;|Routes request| C1\n    API --&gt;|Routes request| C2\n    API --&gt;|Routes request| C3\n    API --&gt;|Routes request| C4\n    API --&gt;|Routes request| C5\n    API --&gt;|Routes request| C6\n\n    C2 -.-&gt;|Read/Write| DB1\n    C3 -.-&gt;|Read/Write| DB3\n    C4 -.-&gt;|Read/Write| DB2\n\n    C1 &lt;--&gt;|API calls| C2\n    C1 &lt;--&gt;|API calls| C4\n    C3 &lt;--&gt;|API calls| C4</code></pre> <p>Tip</p> <p>Tools like Docker help create containers, while systems like Kubernetes help manage many containers.</p>"},{"location":"System%20Design%20Fundamental/#server-infrastructure","title":"Server Infrastructure","text":"<p>We often categorize servers by their primary function rather than their underlying technology.</p>"},{"location":"System%20Design%20Fundamental/#infrastructure-components","title":"Infrastructure Components","text":""},{"location":"System%20Design%20Fundamental/#web-server","title":"Web Server","text":"<p>A server with a specialized software that handles HTTP requests from clients (typically browsers). It directly serves static content (HTML, CSS, JavaScript, images), forwards requests for dynamic content to backend servers for processing, and returns appropriate responses to the client.</p> <p>Primary Function</p> <ul> <li>Focus on serving web content, handling HTTP protocols, and routing requests</li> </ul> <p>Examples</p> <ul> <li>IIS, Nginx, Apache HTTP Server</li> </ul>"},{"location":"System%20Design%20Fundamental/#reverse-proxy","title":"Reverse Proxy","text":"<p>A server with a specialized software that sits between client devices and backend servers, intercepting client requests and forwarding them to appropriate backend servers while providing security, SSL termination, and caching.</p> <p>Primary Function</p> <ul> <li>Focus on request forwarding, content caching, and security</li> </ul> <p>Examples</p> <ul> <li>Nginx, IIS with Application Request Routing (ARR), Apache with mod_proxy</li> </ul>"},{"location":"System%20Design%20Fundamental/#load-balancer","title":"Load Balancer","text":"<p>A server with a specialized software that distributes incoming client requests across multiple servers to ensure high availability, avoid traffic overload, prevent single points of failure, and enable horizontal scaling.</p> <p>Primary Function</p> <ul> <li>Focus on traffic distribution and high availability</li> </ul> <p>Examples</p> <ul> <li>Load Balancing Software: Microsoft Network Load Balancing (NLB), Nginx, HAProxy</li> <li>Cloud-based Services: AWS Elastic Load Balancing, Azure Load Balancer</li> </ul>"},{"location":"System%20Design%20Fundamental/#api-gateway","title":"API Gateway","text":"<p>A server with a specialized software that acts as a single entry point for client applications to access multiple backend services and APIs. It serves as a reverse proxy for API requests while providing additional functionality such as request routing, authentication, and monitoring.</p> <p>Primary Function</p> <ul> <li>Focus on API traffic management, security, and request coordination across multiple services</li> </ul> <p>Examples</p> <ul> <li>Cloud-based Services: Azure API Management, Amazon API Gateway</li> <li>Software: Kong, Apigee, Tyk</li> </ul>"},{"location":"System%20Design%20Fundamental/#cdn-content-delivery-network","title":"CDN (Content Delivery Network)","text":"<p>A distributed network of servers that caches and delivers web content from the server closest to users, improving performance and user experience.</p> <p>Key Characteristic</p> <ul> <li>Distributed globally to optimize content delivery</li> </ul> <p>Examples</p> <ul> <li>CloudFlare, Akamai, Fastly</li> </ul>"},{"location":"System%20Design%20Fundamental/#networking-communication","title":"Networking &amp; Communication","text":""},{"location":"System%20Design%20Fundamental/#network-models","title":"Network Models","text":""},{"location":"System%20Design%20Fundamental/#osi-model-simplified","title":"OSI Model Simplified","text":"<p>A simplified view of the most relevant layers for software development:</p> <p>Key Layers</p> <ul> <li>Application Layer (L7): HTTP, HTTPS, FTP, SMTP</li> <li>Transport Layer (L4): TCP, UDP</li> <li>Network Layer (L3): IP, Routing</li> <li>Physical/Data Link (L1/L2): Hardware, MAC addresses</li> </ul>"},{"location":"System%20Design%20Fundamental/#tcpip-model","title":"TCP/IP Model","text":"<p>Four-layer model that combines several OSI layers into a more practical framework:</p> <p>Layers</p> <ol> <li>Link Layer: Network interface (Ethernet)</li> <li>Internet Layer: Routing packets across networks (IP)</li> <li>Transport Layer: End-to-end data delivery (TCP, UDP)</li> <li>Application Layer: End-user services (HTTP, FTP, SMTP)</li> </ol>"},{"location":"System%20Design%20Fundamental/#network-addressing","title":"Network Addressing","text":""},{"location":"System%20Design%20Fundamental/#ip-address","title":"IP Address","text":"<p>Numerical label assigned to devices on a network, used to identify and locate them for communication.</p> <p>Types</p> <ul> <li>IPv4: 32-bit addresses (e.g., 192.168.1.1)</li> <li>IPv6: 128-bit addresses (e.g., 2001:0db8:85a3:0000:0000:8a2e:0370:7334)</li> <li>Private vs Public IPs</li> <li>Localhost (127.0.0.1)</li> </ul>"},{"location":"System%20Design%20Fundamental/#port-numbers","title":"Port Numbers","text":"<p>Logical endpoints for network communication:</p> <p>Common Ports</p> <ul> <li>80: HTTP</li> <li>443: HTTPS</li> <li>22: SSH</li> <li>3306: MySQL</li> <li>5432: PostgreSQL</li> <li>27017: MongoDB</li> </ul>"},{"location":"System%20Design%20Fundamental/#dns-domain-name-system","title":"DNS (Domain Name System)","text":"<p>System that translates human-readable domain names into IP addresses computers use to identify each other.</p> <p>Common Record Types</p> <ul> <li>A Record: Maps hostname to IPv4 address</li> <li>CNAME: Canonical name record (alias)</li> <li>MX: Mail exchange record</li> <li>TXT: Text record, often used for verification</li> </ul> <p>Process</p> <ul> <li>When you enter \"example.com\" in a browser, DNS resolves this to an IP address like 93.184.216.34</li> </ul>"},{"location":"System%20Design%20Fundamental/#communication-protocols","title":"Communication Protocols","text":""},{"location":"System%20Design%20Fundamental/#tcp-vs-udp","title":"TCP vs UDP","text":"<p>Understanding when to use each protocol:</p> Feature TCP UDP Connection Connection-oriented Connectionless Reliability Guaranteed delivery Best effort delivery Order Maintains order No order guarantee Use Case Web, APIs, Database Streaming, Gaming, DNS"},{"location":"System%20Design%20Fundamental/#httphttps","title":"HTTP/HTTPS","text":"<p>Protocols for transmitting web content; HTTPS adds encryption for secure data transfer.</p> <p>Key Concepts</p> <ul> <li>Request/Response Model</li> <li>Headers and Body</li> <li>Status Codes (2xx, 3xx, 4xx, 5xx)</li> <li>CORS and Security</li> <li>Caching Mechanisms</li> </ul> <p>Common Methods</p> <ul> <li>GET: Retrieve data</li> <li>POST: Submit data</li> <li>PUT: Update existing resources</li> <li>DELETE: Remove resources</li> </ul>"},{"location":"System%20Design%20Fundamental/#http-versions","title":"HTTP Versions","text":"<p>Evolution and key improvements:</p> <p>Version Features</p> <ul> <li>HTTP/1.1: Basic persistent connections</li> <li>HTTP/2: Multiplexing, Server Push</li> <li>HTTP/3: QUIC protocol, improved performance</li> </ul>"},{"location":"System%20Design%20Fundamental/#tlsssl","title":"TLS/SSL","text":"<p>Cryptographic protocols that provide secure communication over a computer network, commonly used in HTTPS.</p> <p>Security Best Practice</p> <ul> <li>Always use TLS 1.2 or higher; older versions have known vulnerabilities</li> </ul>"},{"location":"System%20Design%20Fundamental/#websockets","title":"WebSockets","text":"<p>Communication protocol that provides full-duplex communication channels over a single TCP connection.</p> <p>When to Use</p> <ul> <li>Ideal for real-time applications like chat, live notifications, and collaborative tools</li> </ul>"},{"location":"System%20Design%20Fundamental/#performance-metrics","title":"Performance Metrics","text":""},{"location":"System%20Design%20Fundamental/#latency","title":"Latency","text":"<p>The time delay between a request being sent and the response being received, often measured in milliseconds.</p> <p>Typical Values</p> <ul> <li>Low latency: &lt; 100ms</li> <li>Medium latency: 100-300ms</li> <li>High latency: &gt; 300ms</li> </ul>"},{"location":"System%20Design%20Fundamental/#throughput","title":"Throughput","text":"<p>The amount of data that can be transferred from one point to another in a given time period.</p> <p>Common Units</p> <ul> <li>Kbps (Kilobits per second)</li> <li>Mbps (Megabits per second)</li> <li>Gbps (Gigabits per second)</li> </ul>"},{"location":"System%20Design%20Fundamental/#bandwidth","title":"Bandwidth","text":"<p>The maximum data transfer rate of a network or internet connection.</p> <p>Typical Values</p> <ul> <li>Home broadband: 25-1000 Mbps</li> <li>Business connections: 100 Mbps to 10+ Gbps</li> <li>Data center connections: Multiple 10/40/100 Gbps links</li> </ul>"},{"location":"System%20Design%20Fundamental/#packet-loss","title":"Packet Loss","text":"<p>Percentage of packets that fail to reach their destination.</p> <p>Impact</p> <ul> <li>&lt;1%: Generally acceptable</li> <li>1-2.5%: Noticeable impact on real-time applications</li> <li>&gt;3%: Significant degradation in service quality</li> </ul>"},{"location":"System%20Design%20Fundamental/#jitter","title":"Jitter","text":"<p>Variation in the delay of received packets.</p> <p>Acceptable Values</p> <ul> <li>&lt;30ms: Good for VoIP and video calling</li> <li>&gt;30ms: May cause quality issues in real-time communications</li> </ul>"},{"location":"System%20Design%20Fundamental/#api-development-management","title":"API Development &amp; Management","text":""},{"location":"System%20Design%20Fundamental/#api-architecture","title":"API Architecture","text":"REST APIGraphQLgRPC <p>Architectural style for designing networked applications using HTTP methods and stateless operations.</p> <p>Key Principles</p> <ul> <li>Stateless</li> <li>Resource-based</li> <li>Uses standard HTTP methods</li> <li>Representation-oriented</li> </ul> <p>Query language and runtime for APIs that allows clients to request exactly the data they need.</p> <p>Advantages</p> <ul> <li>Single endpoint for all operations</li> <li>Clients specify exactly what data they need</li> <li>Strongly typed schema</li> <li>Reduces over-fetching and under-fetching of data</li> </ul> <p>High-performance, open-source universal RPC framework using Protocol Buffers.</p> <p>Key Features</p> <ul> <li>Uses HTTP/2 for transport</li> <li>Binary serialization with Protocol Buffers</li> <li>Strongly typed contracts</li> <li>Supports streaming: unary, server, client, and bidirectional</li> </ul>"},{"location":"System%20Design%20Fundamental/#api-communication-mechanisms","title":"API Communication Mechanisms","text":""},{"location":"System%20Design%20Fundamental/#polling","title":"Polling","text":"<p>Client regularly checks the server for new data at fixed intervals.</p> <p>Considerations</p> <ul> <li>Simple but inefficient for real-time data; generates unnecessary requests</li> </ul>"},{"location":"System%20Design%20Fundamental/#long-polling","title":"Long Polling","text":"<p>Client makes a request to the server, and the server holds the connection open until new data is available.</p> <p>Best For</p> <ul> <li>Simple real-time applications where WebSockets might be overkill</li> </ul>"},{"location":"System%20Design%20Fundamental/#webhooks","title":"Webhooks","text":"<p>HTTP callbacks that deliver data to other applications in real-time when specific events occur.</p> <p>Common Use Cases</p> <ul> <li>Payment processing notifications</li> <li>CI/CD pipeline events</li> <li>CRM updates</li> </ul>"},{"location":"System%20Design%20Fundamental/#circuit-breaker","title":"Circuit Breaker","text":"<p>Pattern that prevents cascading failures by stopping requests to failing services.</p> <p>States</p> <ul> <li>Closed: Requests flow normally</li> <li>Open: Requests immediately fail without attempting to call the service</li> <li>Half-Open: Limited requests allowed to test if service has recovered</li> </ul>"},{"location":"System%20Design%20Fundamental/#api-reliability-protection","title":"API Reliability &amp; Protection","text":""},{"location":"System%20Design%20Fundamental/#rate-limiting","title":"Rate Limiting","text":"<p>Strategy to restrict the number of API requests a user can make within a specified time period.</p> <p>Common Approaches</p> <ul> <li>Fixed window</li> <li>Sliding window</li> <li>Token bucket</li> <li>Leaky bucket</li> </ul>"},{"location":"System%20Design%20Fundamental/#throttling","title":"Throttling","text":"<p>Mechanism to control the usage of APIs by limiting the rate at which consumers can make calls.</p> <p>Implementation</p> <ul> <li>Should return 429 (Too Many Requests) status code with Retry-After header</li> </ul>"},{"location":"System%20Design%20Fundamental/#idempotency","title":"Idempotency","text":"<p>Property where multiple identical requests have the same effect as a single request.</p> <p>HTTP Methods</p> <ul> <li>Naturally idempotent: GET, PUT, DELETE</li> <li>Not naturally idempotent: POST (requires idempotency keys)</li> </ul>"},{"location":"System%20Design%20Fundamental/#backoff-strategies","title":"Backoff Strategies","text":"<p>Technique where a client progressively increases the delay between retries after failed requests.</p> <p>Common Types</p> <ul> <li>Exponential backoff: Wait times increase exponentially (1s, 2s, 4s, 8s...)</li> <li>Jittered backoff: Adds randomness to avoid thundering herd problems</li> </ul>"},{"location":"System%20Design%20Fundamental/#database-storage","title":"Database &amp; Storage","text":""},{"location":"System%20Design%20Fundamental/#database-types","title":"Database Types","text":"SQL DatabaseNoSQL DatabaseTSDB (Time Series Database) <p>Relational database that uses structured query language for defining and manipulating data.</p> <p>Popular Implementations</p> <ul> <li>PostgreSQL</li> <li>MySQL</li> <li>SQL Server</li> <li>Oracle</li> </ul> <p>Best For</p> <p>Complex queries, transactions, and data with well-defined relationships</p> <p>Non-relational database designed for distributed data stores with diverse data models.</p> <p>Common Types</p> <ul> <li>Document stores: MongoDB, Couchbase</li> <li>Key-value stores: Redis, DynamoDB</li> <li>Column-family stores: Cassandra, HBase</li> <li>Graph databases: Neo4j, Amazon Neptune</li> </ul> <p>Best For</p> <p>Scalability, flexibility with unstructured data, high write throughput</p> <p>Database optimized for time-stamped or time series data.</p> <p>Popular Implementations</p> <ul> <li>InfluxDB</li> <li>TimescaleDB (PostgreSQL extension)</li> <li>Prometheus</li> </ul> <p>Best For</p> <p>Metrics, monitoring data, IoT sensor data, financial market data</p>"},{"location":"System%20Design%20Fundamental/#data-partition","title":"Data Partition","text":""},{"location":"System%20Design%20Fundamental/#partitioning-vertical-partitioning","title":"Partitioning (Vertical Partitioning)","text":"<p>Division of a database table into multiple tables by columns, with each table having fewer columns.</p> <p>Use Case</p> <ul> <li>Splitting a wide table with customer profile data, purchase history, and preferences into separate tables by data category</li> </ul>"},{"location":"System%20Design%20Fundamental/#sharding-horizontal-partitioning","title":"Sharding (Horizontal Partitioning)","text":"<p>Database architecture pattern where rows of a database table are held separately in different database nodes.</p> <p>Common Sharding Strategies</p> <ul> <li>Range-based: Partition by ranges of a key (e.g., customer_id 1-1000, 1001-2000)</li> <li>Hash-based: Use a hash function on the key</li> <li>Directory-based: Maintain a lookup table mapping keys to shards</li> </ul>"},{"location":"System%20Design%20Fundamental/#database-optimization","title":"Database Optimization","text":""},{"location":"System%20Design%20Fundamental/#database-indexing","title":"Database Indexing","text":"<p>Data structure technique to improve the speed of data retrieval operations.</p> <p>Tradeoffs</p> <ul> <li>Indexes speed up reads but slow down writes and require additional storage</li> </ul> <p>Best Practices</p> <ul> <li>Index columns used in WHERE clauses and joins</li> <li>Avoid over-indexing</li> <li>Consider composite indexes for multi-column queries</li> </ul>"},{"location":"System%20Design%20Fundamental/#denormalization","title":"Denormalization","text":"<p>Strategy to improve read performance by adding redundant data or grouping data.</p> <p>Techniques</p> <ul> <li>Materialized views</li> <li>Precomputed aggregates</li> <li>Redundant fields</li> </ul>"},{"location":"System%20Design%20Fundamental/#storage-solutions","title":"Storage Solutions","text":""},{"location":"System%20Design%20Fundamental/#blob-storage","title":"Blob Storage","text":"<p>System for storing large binary objects, such as images, videos, or documents.</p> <p>Services</p> <ul> <li>AWS S3</li> <li>Azure Blob Storage</li> <li>Google Cloud Storage</li> </ul> <p>Best For</p> <ul> <li>Unstructured data like media files, backups, and static website content</li> </ul>"},{"location":"System%20Design%20Fundamental/#scalability-performance","title":"Scalability &amp; Performance","text":""},{"location":"System%20Design%20Fundamental/#scaling-strategies","title":"Scaling Strategies","text":""},{"location":"System%20Design%20Fundamental/#vertical-scaling","title":"Vertical Scaling","text":"<p>Increasing the capacity of a single server by adding more resources (CPU, RAM).</p> <p>Pros and Cons</p> <ul> <li>Pros: Simple, no distribution complexity</li> <li>Cons: Limited by hardware capacity, expensive at high end</li> </ul>"},{"location":"System%20Design%20Fundamental/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>Adding more machines to a system to handle increased load, distributing processing across multiple servers.</p> <p>Pros and Cons</p> <ul> <li>Pros: Linear cost scaling, high availability, fault tolerance</li> <li>Cons: Increased complexity, data consistency challenges</li> </ul>"},{"location":"System%20Design%20Fundamental/#performance-optimization","title":"Performance Optimization","text":""},{"location":"System%20Design%20Fundamental/#replication","title":"Replication","text":"<p>Process of creating and maintaining duplicate copies of data across multiple nodes.</p> <p>Types</p> <ul> <li>Master-slave: One primary write node, multiple read replicas</li> <li>Multi-master: Multiple nodes accept writes</li> <li>Peer-to-peer: All nodes are equal</li> </ul>"},{"location":"System%20Design%20Fundamental/#caching","title":"Caching","text":"<p>Temporary storage of copies of data to reduce retrieval time and server load.</p> <p>Caching Levels</p> <ul> <li>Client-side: Browser cache, mobile app cache</li> <li>CDN caching: Edge locations</li> <li>Application caching: In-memory caches like Redis</li> <li>Database caching: Query cache, buffer pool</li> </ul>"},{"location":"System%20Design%20Fundamental/#reliability-consistency","title":"Reliability &amp; Consistency","text":""},{"location":"System%20Design%20Fundamental/#consistency-models","title":"Consistency Models","text":""},{"location":"System%20Design%20Fundamental/#acid-properties","title":"ACID Properties","text":"<p>Set of database transaction properties (Atomicity, Consistency, Isolation, Durability) that guarantee valid transactions.</p> <p>Components</p> <ul> <li>Atomicity: Transactions are all-or-nothing</li> <li>Consistency: Transactions bring the database from one valid state to another</li> <li>Isolation: Concurrent transactions don't interfere with each other</li> <li>Durability: Committed transactions persist even after system failures</li> </ul>"},{"location":"System%20Design%20Fundamental/#base-properties","title":"BASE Properties","text":"<p>Alternative to ACID for distributed systems: Basically Available, Soft state, Eventually consistent.</p> <p>Components</p> <ul> <li>Basically Available: System guarantees availability</li> <li>Soft state: State may change over time without input</li> <li>Eventually consistent: System will become consistent over time</li> </ul>"},{"location":"System%20Design%20Fundamental/#cap-theorem","title":"CAP Theorem","text":"<p>States that distributed systems can provide at most two of three guarantees: Consistency, Availability, and Partition tolerance.</p> <p>System Classifications</p> <ul> <li>CP (Consistent, Partition-tolerant): MongoDB, HBase</li> <li>AP (Available, Partition-tolerant): Cassandra, DynamoDB</li> <li>CA (Consistent, Available): Traditional RDBMS (not partition-tolerant)</li> </ul>"},{"location":"System%20Design%20Fundamental/#reliability-patterns","title":"Reliability Patterns","text":""},{"location":"System%20Design%20Fundamental/#failover","title":"Failover","text":"<p>Backup operational mode where functions are automatically transferred to standby system components.</p> <p>Types</p> <ul> <li>Active-passive: Standby server only activates when primary fails</li> <li>Active-active: Multiple servers handle traffic, survivors take over on failure</li> </ul>"},{"location":"System%20Design%20Fundamental/#software-architecture-design","title":"Software Architecture &amp; Design","text":""},{"location":"System%20Design%20Fundamental/#software-architecture-patterns","title":"Software Architecture Patterns","text":"Monolithic ArchitectureMicroservices ArchitectureService-Oriented Architecture (SOA) <p>A software design pattern where an application is built as a single, unified codebase with tightly coupled components (user interface, business logic, data access).</p> <pre><code>flowchart TD\n    subgraph \"Monolithic Application\"\n        UI[User Interface Layer]\n        BL[Business Logic Layer]\n        DAL[Data Access Layer]\n        DB[(Database)]\n\n        Client[Client] --&gt;|Request| UI\n        UI --&gt;|Process| BL\n        BL --&gt;|Store/Retrieve| DAL\n        DAL --&gt;|Query| DB\n    end\n\n    note[Single Deployable Unit: All components &lt;br&gt; are packaged and deployed together]\n    style note fill:#f9f,stroke:#333,stroke-width:1px</code></pre> <p>Pros</p> <ul> <li>Simplicity</li> <li>Easier to debug</li> <li>Faster initial development</li> </ul> <p>Cons</p> <ul> <li>Harder to scale</li> <li>Can become complex and hard to maintain</li> <li>Team coordination challenges</li> </ul> <p>A software design pattern where an application is built as a collection of small, independent services that communicate over a network. Each microservice focuses on a specific business function and maintains its own data.</p> <pre><code>flowchart TD\nClient[Client] --&gt; API[API Gateway]\n\n    subgraph \"Microservice 1: User Service\"\n        US[User Service] --&gt; UDB[(User DB)]\n    end\n\n    subgraph \"Microservice 2: Order Service\"\n        OS[Order Service] --&gt; ODB[(Order DB)]\n    end\n\n    subgraph \"Microservice 3: Product Service\"\n        PS[Product Service] --&gt; PDB[(Product DB)]\n    end\n\n    subgraph \"Microservice 4: Payment Service\"\n        PAYS[Payment Service] --&gt; PAYDB[(Payment DB)]\n    end\n\n    API --&gt; US\n    API --&gt; OS\n    API --&gt; PS\n    API --&gt; PAYS\n\n    OS --&gt;|Communication| PS\n    OS --&gt;|Communication| PAYS\n\n    note[Independent Services - &lt;br&gt;Each with its own database &lt;br&gt;and deployment pipeline]\n    style note fill:#afd,stroke:#333,stroke-width:1px</code></pre> <p>Pros</p> <ul> <li>Independent scaling</li> <li>Technology flexibility</li> <li>Easier for team collaboration</li> <li>Fault isolation</li> </ul> <p>Cons</p> <ul> <li>Complex to set up and manage</li> <li>Harder to test end-to-end</li> <li>Data consistency challenges</li> <li>Network overhead</li> </ul> <p>A software design pattern that focuses on building reusable services to serve multiple applications across an entire organization. These services typically communicate through standardized interfaces or an ESB (Enterprise Service Bus), enabling different applications to use these services regardless of the underlying technologies.</p> <pre><code>flowchart TD\nApp1[Application 1] --&gt; ESB\nApp2[Application 2] --&gt; ESB\nApp3[Application 3] --&gt; ESB\n\n    subgraph \"Enterprise Service Bus (ESB)\"\n        ESB[Enterprise Service Bus]\n    end\n\n    ESB --&gt; S1\n    ESB --&gt; S2\n    ESB --&gt; S3\n    ESB --&gt; S4\n\n    subgraph \"Shared Services\"\n        S1[Customer Service]\n        S2[Product Catalog Service]\n        S3[Order Processing Service]\n        S4[Authentication Service]\n    end\n\n    S1 --&gt; DB1[(Shared Database)]\n    S2 --&gt; DB1\n    S3 --&gt; DB1\n    S4 --&gt; DB2[(Auth Database)]\n\n    note[Business-aligned services &lt;br&gt;with centralized communication &lt;br&gt;through Enterprise Service Bus]\n    style note fill:#ccf,stroke:#333,stroke-width:1px</code></pre> <p>Pros</p> <ul> <li>Reusable services</li> <li>Business-aligned modularity</li> <li>Can integrate legacy systems</li> <li>Standardized interfaces</li> </ul> <p>Cons</p> <ul> <li>Complex to manage</li> <li>Centralized ESB can become a performance bottleneck and single point of failure</li> <li>Often requires significant governance</li> </ul>"},{"location":"System%20Design%20Fundamental/#microservices-design-patterns","title":"Microservices Design Patterns","text":""},{"location":"System%20Design%20Fundamental/#api-gateway_1","title":"API Gateway","text":"<p>The API Gateway pattern provides a unified entry point for clients to interact with a system of microservices.</p> <p>Implementation Considerations</p> <p>Should handle cross-cutting concerns like authentication, logging, and request routing</p>"},{"location":"System%20Design%20Fundamental/#service-discovery","title":"Service Discovery","text":"<p>Service that enables microservices to find and communicate with each other without hardcoded locations.</p> <p>Implementation Options</p> <ul> <li>Client-side discovery: Services query a registry (e.g., Netflix Eureka)</li> <li>Server-side discovery: Load balancer routes requests (e.g., Kubernetes Service)</li> </ul>"},{"location":"System%20Design%20Fundamental/#saga-pattern","title":"Saga Pattern","text":"<p>Sequence of local transactions where each transaction updates data within a single service.</p> <p>Coordination Methods</p> <ul> <li>Choreography: Each service publishes events that trigger other services</li> <li>Orchestration: Central coordinator directs the saga steps</li> </ul>"},{"location":"System%20Design%20Fundamental/#circuit-breaker_1","title":"Circuit Breaker","text":"<p>Pattern that prevents cascading failures by stopping requests to failing services.</p> <p>Libraries</p> <ul> <li>Netflix Hystrix</li> <li>Resilience4j</li> <li>Polly (.NET)</li> </ul>"},{"location":"System%20Design%20Fundamental/#sidecar-pattern","title":"Sidecar Pattern","text":"<p>Deploys components of an application as separate processes or containers to provide isolation and encapsulation.</p> <p>Common Uses</p> <ul> <li>Service mesh proxies (Istio, Linkerd)</li> <li>Logging agents</li> <li>Configuration agents</li> </ul>"},{"location":"System%20Design%20Fundamental/#cqrs-command-query-responsibility-segregation","title":"CQRS (Command Query Responsibility Segregation)","text":"<p>Pattern that separates read and write operations to optimize performance, scalability, and security.</p> <p>When to Use</p> <ul> <li>When read and write workloads have significantly different performance and scaling requirements</li> </ul>"},{"location":"System%20Design%20Fundamental/#event-driven-architecture","title":"Event-Driven Architecture","text":"<p>Design paradigm where components communicate through events, promoting loose coupling and scalability.</p> <p>Implementation Technologies</p> <ul> <li>Kafka</li> <li>RabbitMQ</li> <li>AWS EventBridge</li> <li>Azure Event Grid</li> </ul>"},{"location":"System%20Design%20Fundamental/#strangler-pattern","title":"Strangler Pattern","text":"<p>A migration pattern/strategy for incrementally replacing a legacy system by gradually routing functionality to new services.</p> <p>Implementation Steps</p> <ol> <li>Create a facade in front of the legacy system</li> <li>Gradually build new functionality behind the facade</li> <li>Incrementally redirect from legacy to new implementation</li> <li>Remove legacy code when no longer used</li> </ol>"},{"location":"System%20Design%20Fundamental/#software-design-approaches-design-methodologies","title":"Software Design Approaches (Design Methodologies)","text":""},{"location":"System%20Design%20Fundamental/#domain-driven-design-ddd","title":"Domain-Driven Design (DDD)","text":"<p>Software development approach focusing on the core domain and domain logic.</p> <p>Key Concepts</p> <ul> <li>Bounded contexts</li> <li>Ubiquitous language</li> <li>Aggregates</li> <li>Domain events</li> <li>Repositories</li> </ul>"},{"location":"System%20Design%20Fundamental/#test-driven-development-tdd","title":"Test-Driven Development (TDD)","text":"<p>Development process where tests are written before code implementation, guiding the design through failing tests that are later made to pass.</p> <p>TDD Cycle</p> <ol> <li>Write a failing test</li> <li>Write minimal code to pass the test</li> <li>Refactor while maintaining passing tests</li> </ol>"},{"location":"System%20Design%20Fundamental/#event-sourcing","title":"Event Sourcing","text":"<p>Storing changes to application state as a sequence of events rather than just the current state.</p> <p>Benefits</p> <ul> <li>Complete audit history</li> <li>Time travel (reconstruct past states)</li> <li>Excellent for debugging and analysis</li> </ul>"},{"location":"backend/Backend%20Development/","title":"Backend Development","text":"<p>\ud83d\udea7 This section is currently under development \ud83d\udea7</p>"},{"location":"backend/Backend%20Development/#coming-soon","title":"Coming Soon","text":"<p>This section will cover various aspects of backend development, including:</p> <ul> <li>Server-side programming concepts and best practices</li> <li>API design and development</li> <li>Database systems and data modeling</li> <li>Performance optimization and scaling</li> <li>Security considerations</li> <li>Testing and deployment strategies</li> </ul> <p>Stay tuned as I continue to build out this knowledge base with practical examples and insights from my learning journey.</p> <p>_Last updated: April 2025</p>"},{"location":"data-structures-and-algorithms/Data%20Structures%20%26%20Algorithms/","title":"Data Structures &amp; Algorithms","text":"<p>\ud83d\udea7 This section is currently under development \ud83d\udea7</p>"},{"location":"data-structures-and-algorithms/Data%20Structures%20%26%20Algorithms/#coming-soon","title":"Coming Soon","text":"<p>This section will cover various aspects of data structures and algorithms, including:</p> <ul> <li>Fundamental data structures and their implementations</li> <li>Algorithm design and analysis</li> <li>Problem-solving strategies and patterns</li> <li>Time and space complexity analysis</li> <li>Common algorithm categories (sorting, searching, graph algorithms, etc.)</li> <li>Practical applications and optimization techniques</li> </ul> <p>Stay tuned as I continue to build out this knowledge base with practical examples and insights from my learning journey.</p> <p>_Last updated: April 2025</p>"},{"location":"frontend/Frontend%20Development/","title":"Frontend Development","text":"<p>\ud83d\udea7 This section is currently under development \ud83d\udea7</p>"},{"location":"frontend/Frontend%20Development/#coming-soon","title":"Coming Soon","text":"<p>This section will cover various aspects of frontend development, including:</p> <ul> <li>Modern web technologies and frameworks</li> <li>UI/UX design principles and best practices</li> <li>Responsive design and accessibility</li> <li>State management and performance optimization</li> <li>Testing and debugging techniques</li> <li>Build tools and workflows</li> </ul> <p>Stay tuned as I continue to build out this knowledge base with practical examples and insights from my learning journey.</p> <p>_Last updated: April 2025</p>"},{"location":"fundamentals/api/","title":"API Development &amp; Management","text":""},{"location":"fundamentals/api/#application-protocols","title":"Application Protocols","text":""},{"location":"fundamentals/api/#httphttps","title":"HTTP/HTTPS","text":"<p>Protocols for transmitting web content; HTTPS adds encryption for secure data transfer.</p> <p>Key Concepts</p> <ul> <li>Request/Response Model</li> <li>Headers and Body</li> <li>Status Codes (2xx, 3xx, 4xx, 5xx)</li> <li>CORS and Security</li> <li>Caching Mechanisms</li> </ul> <p>Common Methods</p> <ul> <li>GET: Retrieve data</li> <li>POST: Submit data</li> <li>PUT: Update existing resources</li> <li>DELETE: Remove resources</li> </ul>"},{"location":"fundamentals/api/#http-versions","title":"HTTP Versions","text":"<p>Evolution and key improvements:</p> <p>Version Features</p> <ul> <li>HTTP/1.1: Basic persistent connections</li> <li>HTTP/2: Multiplexing, Server Push</li> <li>HTTP/3: QUIC protocol, improved performance</li> </ul>"},{"location":"fundamentals/api/#websockets","title":"WebSockets","text":"<p>Communication protocol that provides full-duplex communication channels over a single TCP connection.</p> <p>When to Use</p> <ul> <li>Ideal for real-time applications like chat, live notifications, and collaborative tools</li> </ul>"},{"location":"fundamentals/api/#api-architecture","title":"API Architecture","text":"<p>API Architecture defines the overall design approach for building and exposing APIs. Different architectural styles offer various tradeoffs in terms of complexity, performance, and flexibility.</p>"},{"location":"fundamentals/api/#rest-representational-state-transfer","title":"REST (Representational State Transfer)","text":"<p>Architectural style for designing networked applications using HTTP methods and stateless operations.</p> <p>Key Principles</p> <ul> <li>Stateless</li> <li>Resource-based</li> <li>Uses standard HTTP methods</li> <li>Representation-oriented</li> </ul> <p>When to Use</p> <ul> <li>Public APIs with diverse clients</li> <li>Mobile applications</li> <li>Web applications</li> <li>When HTTP caching is beneficial</li> <li>For systems requiring simple, standards-based integration</li> </ul>"},{"location":"fundamentals/api/#soap-simple-object-access-protocol","title":"SOAP (Simple Object Access Protocol)","text":"<p>A protocol specification for exchanging structured information in web services using XML. It defines a standardized format for messages and a set of rules for communication between applications.</p> <p>Characteristics</p> <ul> <li>XML-based messaging format</li> <li>Platform and language independent</li> <li>Strong typing and validation</li> <li>Supports multiple transport protocols (HTTP, SMTP, TCP)</li> <li>Built-in error handling with SOAP Fault</li> <li>Uses WSDL (Web Services Description Language) for service definition</li> </ul> <p>When to Use</p> <ul> <li>Enterprise integration requiring formal contracts, such as enterprise web services</li> <li>Financial transactions and healthcare information exchange requiring security</li> <li>Government systems integration and regulated industries</li> <li>Legacy system integration with strict reliability requirements</li> </ul>"},{"location":"fundamentals/api/#graphql","title":"GraphQL","text":"<p>Query language and runtime for APIs that allows clients to request exactly the data they need.</p> <p>Advantages</p> <ul> <li>Single endpoint for all operations</li> <li>Clients specify exactly what data they need</li> <li>Strongly typed schema</li> <li>Reduces over-fetching and under-fetching of data</li> </ul> <p>When to Use</p> <ul> <li>Applications with complex data requirements</li> <li>Mobile apps needing to minimize bandwidth usage</li> <li>APIs serving multiple client types with different needs</li> <li>Rapidly evolving frontends with changing data requirements</li> </ul> <p>Considerations</p> <ul> <li>More complex server implementation</li> <li>Potential for performance issues with nested queries</li> <li>Caching is more challenging than REST</li> <li>Requires specialized tooling and client libraries</li> </ul>"},{"location":"fundamentals/api/#grpc","title":"gRPC","text":"<p>High-performance, open-source universal RPC framework using Protocol Buffers.</p> <p>Key Features</p> <ul> <li>Uses HTTP/2 for transport</li> <li>Binary serialization with Protocol Buffers</li> <li>Strongly typed contracts</li> <li>Supports streaming: unary, server, client, and bidirectional</li> </ul> <p>When to Use</p> <ul> <li>Microservice communication requiring high performance</li> <li>Real-time communication with bidirectional streaming</li> <li>Polyglot environments (services written in different languages)</li> <li>IoT systems with limited bandwidth</li> <li>Low-latency, high-throughput communication</li> </ul> <p>Limitations</p> <ul> <li>Limited browser support</li> <li>Less human-readable than JSON</li> <li>Requires Protocol Buffer compilation</li> <li>Less suitable for public APIs</li> </ul>"},{"location":"fundamentals/api/#api-implementation-considerations","title":"API Implementation Considerations","text":""},{"location":"fundamentals/api/#api-versioning","title":"API Versioning","text":"<p>Strategies for evolving APIs while maintaining backward compatibility.</p> <p>Common Approaches</p> <ul> <li>URL path versioning: <code>/api/v1/resources</code></li> <li>Query parameter: <code>/api/resources?version=1</code></li> <li>Header-based: <code>Accept: application/vnd.company.v1+json</code></li> <li>Content negotiation: <code>Accept: application/json;version=1</code></li> </ul>"},{"location":"fundamentals/api/#api-documentation","title":"API Documentation","text":"<p>Tools and formats for documenting APIs to improve developer experience.</p> <p>Standards &amp; Tools</p> <ul> <li>OpenAPI/Swagger: REST API specification</li> <li>RAML: RESTful API Modeling Language</li> <li>API Blueprint: Markdown-based documentation</li> <li>GraphQL Schema: Self-documenting type system</li> <li>WSDL: Web Services Description Language for SOAP</li> </ul>"},{"location":"fundamentals/api/#api-communication-mechanisms","title":"API Communication Mechanisms","text":"<p>API Communication Mechanisms define how clients and servers exchange information, covering both request-response patterns and event-driven approaches.</p>"},{"location":"fundamentals/api/#polling","title":"Polling","text":"<p>Client regularly checks the server for new data at fixed intervals.</p> <p>Considerations</p> <ul> <li>Simple but inefficient for real-time data; generates unnecessary requests</li> </ul>"},{"location":"fundamentals/api/#long-polling","title":"Long Polling","text":"<p>Client makes a request to the server, and the server holds the connection open until new data is available.</p> <p>Best For</p> <ul> <li>Simple real-time applications where WebSockets might be overkill</li> </ul>"},{"location":"fundamentals/api/#webhooks","title":"Webhooks","text":"<p>Event-driven pattern where HTTP callbacks deliver data to other applications in real-time when specific events occur.</p> <p>Characteristics</p> <ul> <li>Push-based notification mechanism</li> <li>Event-driven communication</li> <li>HTTP POST requests with payload</li> <li>Requires endpoint registration</li> <li>Typically uses JSON or XML for payloads</li> </ul> <p>When to Use</p> <ul> <li>Real-time notifications</li> <li>Integration with third-party services</li> <li>Event-driven architectures</li> <li>Systems requiring asynchronous processing</li> </ul> <p>Common Use Cases</p> <ul> <li>Payment processing notifications</li> <li>Source control commit triggers</li> <li>CRM data change events</li> <li>IoT device state changes</li> </ul>"},{"location":"fundamentals/api/#circuit-breaker","title":"Circuit Breaker","text":"<p>Pattern that prevents cascading failures by stopping requests to failing services.</p> <p>States</p> <ul> <li>Closed: Requests flow normally</li> <li>Open: Requests immediately fail without attempting to call the service</li> <li>Half-Open: Limited requests allowed to test if service has recovered</li> </ul>"},{"location":"fundamentals/api/#api-reliability-protection","title":"API Reliability &amp; Protection","text":""},{"location":"fundamentals/api/#rate-limiting","title":"Rate Limiting","text":"<p>Strategy to restrict the number of API requests a user can make within a specified time period.</p> <p>Common Approaches</p> <ul> <li>Fixed window</li> <li>Sliding window</li> <li>Token bucket</li> <li>Leaky bucket</li> </ul>"},{"location":"fundamentals/api/#throttling","title":"Throttling","text":"<p>Mechanism to control the usage of APIs by limiting the rate at which consumers can make calls.</p> <p>Implementation</p> <ul> <li>Should return 429 (Too Many Requests) status code with Retry-After header</li> </ul>"},{"location":"fundamentals/api/#idempotency","title":"Idempotency","text":"<p>Property where multiple identical requests have the same effect as a single request.</p> <p>HTTP Methods</p> <ul> <li>Naturally idempotent: GET, PUT, DELETE</li> <li>Not naturally idempotent: POST (requires idempotency keys)</li> </ul>"},{"location":"fundamentals/api/#backoff-strategies","title":"Backoff Strategies","text":"<p>Technique where a client progressively increases the delay between retries after failed requests.</p> <p>Common Types</p> <ul> <li>Exponential backoff: Wait times increase exponentially (1s, 2s, 4s, 8s...)</li> <li>Jittered backoff: Adds randomness to avoid thundering herd problems</li> </ul>"},{"location":"fundamentals/client-server/","title":"Client-Server Architecture","text":"<p>A computing model where tasks are distributed between clients (requesters) and servers (providers of resources/services).</p>"},{"location":"fundamentals/client-server/#core-components","title":"Core Components","text":""},{"location":"fundamentals/client-server/#client","title":"Client","text":"<p>End-user (client) devices or applications that communicates with consumer applications to make requests to servers.</p> <p>Examples</p> <ul> <li>Client devices: Web browser, phone, computer</li> <li>Consumer apps: Web application, mobile application</li> </ul>"},{"location":"fundamentals/client-server/#server","title":"Server","text":"<p>Dedicated computers or software that provides services, resources or data to clients over a network to fulfill requests.</p> <p>Key Characteristics</p> <ul> <li>Always-on availability</li> <li>Scalable resources</li> <li>Centralized management</li> <li>Secure access control</li> </ul> <p>Note</p> <p>Servers can be deployed in various ways depending on the requirements.(1)</p> <ol> <li>See Server Infrastructure for information about different deployment models (physical, virtual, containerized, cloud-based)</li> </ol>"},{"location":"fundamentals/client-server/#application-layers","title":"Application Layers","text":""},{"location":"fundamentals/client-server/#frontend","title":"Frontend","text":"<p>Web servers that serve static files (HTML, CSS, JavaScript), routes requests to appropriate backend servers, often acts as the entry point for client application.</p> <p>Important Note</p> <p>All frontend servers are web servers, but not all web servers that serve static files are considered frontend servers (Ex: CDN, Static File Servers).</p> <p>Examples</p> <ul> <li>Node.js with Express: Often used to create custom frontend servers that serve React/Angular/Vue applications</li> <li>Nginx as a frontend proxy: Configured specifically to route and cache frontend resources</li> </ul>"},{"location":"fundamentals/client-server/#backend","title":"Backend","text":"<p>Application servers that host server-side applications that process business logic, handle data operations, and interact with databases and other services.</p> <p>Examples</p> <ul> <li>Application servers running Node.js, Python, Java, .NET, etc.</li> </ul>"},{"location":"fundamentals/client-server/#browserfrontend-app","title":"Browser/Frontend App","text":"<p>A client-side application (1) running on the user's device that provides the interface users interact with directly in their browser.</p> <ol> <li>client-side application: A collection of static files (HTML, CSS, and JavaScript)</li> </ol> <p>Examples</p> <ul> <li>Examples: Web apps developed using frontend frameworks like React, Vue.js, Angular</li> </ul>"},{"location":"fundamentals/client-server/#backend-app","title":"Backend App","text":"<p>Server-side applications (typically stateless services) that run on backend servers, implement business logic and data processing functionalities, and expose APIs for clients to consume.</p> <p>Examples</p> <ul> <li>Applications built with ASP.NET Core, Django, Node.js</li> </ul>"},{"location":"fundamentals/client-server/#application-types","title":"Application Types","text":""},{"location":"fundamentals/client-server/#traditional-web-application","title":"Traditional Web Application","text":"<p>Web applications where pages are fully rendered on the server before being sent to the client.</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant B as Browser\n    participant S as Server\n\n    U-&gt;&gt;B: Initial request\n    B-&gt;&gt;S: GET /page\n    S-&gt;&gt;B: Generate and return complete HTML\n    B-&gt;&gt;U: Display page\n\n    U-&gt;&gt;B: Click link/submit form\n    B-&gt;&gt;S: GET/POST new request\n    S-&gt;&gt;B: Generate and return new complete HTML\n    B-&gt;&gt;U: Display new page (full reload)</code></pre>"},{"location":"fundamentals/client-server/#single-page-application-spa","title":"Single Page Application (SPA)","text":"<p>Web applications that load a single HTML page and dynamically update content without full page reloads.</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant B as Browser\n    participant S as Server\n\n    U-&gt;&gt;B: Initial request\n    B-&gt;&gt;S: GET index.html\n    S-&gt;&gt;B: Return HTML, CSS, JavaScript\n    Note over B: SPA loads completely\n\n    U-&gt;&gt;B: Interact with page\n    B-&gt;&gt;B: Update DOM\n\n    U-&gt;&gt;B: Request new data\n    B-&gt;&gt;S: AJAX call to API\n    S-&gt;&gt;B: Return JSON data\n    B-&gt;&gt;B: Update view without page reload</code></pre> <p>Tip</p> <p>SPAs use AJAX and JavaScript to fetch data from servers and modify the current page without requiring full page reloads.</p>"},{"location":"fundamentals/client-server/#progressive-web-application-pwa","title":"Progressive Web Application (PWA)","text":"<p>Web applications that use modern web technologies to deliver app-like experiences to users.</p> <pre><code>flowchart LR\n    Client[Client] --&gt;|HTTP/HTTPS| SW[Service Worker]\n    SW --&gt;|Cache| CS[Cache Storage]\n    SW --&gt;|Sync| BS[Background Sync]\n    SW --&gt;|Push| PN[Push API]\n\n    Client --&gt;|Install| WM[Web Manifest]\n    WM --&gt;|Metadata| App[PWA]\n    App --&gt;|Offline| SW\n    App --&gt;|Responsive| Client</code></pre> <p>Key Features</p> <p>PWAs are responsive, work offline, can be installed on home screens, support push notifications, and combine the best features of web and mobile applications.</p>"},{"location":"fundamentals/client-server/#deployment-architecture-patterns","title":"Deployment Architecture Patterns","text":""},{"location":"fundamentals/client-server/#single-tier-architecture","title":"Single-Tier Architecture","text":"<p>A deployment strategy where all application components (presentation, logic, data) run on a single server. All components share the same computing resources and system environment.</p> <pre><code>flowchart LR\n    subgraph \"Web server (IIS/Nginx)\"\n        UI[User Interface] --&gt; BL[Business Logic]\n        BL --&gt; DB[(Database)]\n    end\n    User((\"User/Browser\")) --&gt;|HTTP| UI</code></pre>"},{"location":"fundamentals/client-server/#multi-tier-architecture","title":"Multi-Tier Architecture","text":"<p>A deployment strategy that splits application components across multiple servers by deploying them into separate tiers for web servers, application servers, and database servers to improves scalability, enhances maintainability, and strengthens security.</p> <pre><code>flowchart LR\n    User((\"User/Browser\")) --&gt;|HTTP| LB[Load Balancer]\n\n    subgraph \"Presentation Tier\"\n        W1[Web Server 1]\n        W2[Web Server 2]\n    end\n\n    subgraph \"Application Tier\"\n        A1[App Server 1]\n        A2[App Server 2]\n    end\n\n    subgraph \"Data Tier\"\n        DB1[(Primary DB)]\n        DB2[(Replica DB)]\n    end\n\n    LB --&gt; W1\n    LB --&gt; W2\n    W1 --&gt;|API calls| A1\n    W1 --&gt;|API calls| A2\n    W2 --&gt;|API calls| A1\n    W2 --&gt;|API calls| A2\n    A1 --&gt;|SQL| DB1\n    A2 --&gt;|SQL| DB1\n    DB1 -.-&gt;|Replication| DB2</code></pre>"},{"location":"fundamentals/client-server/#containerized-architecture","title":"Containerized Architecture","text":"<p>A deployment strategy using containerization (Docker, etc.) to package application components with their dependencies. This enables consistent deployment across different environments and works with orchestration platforms like Kubernetes.</p> <pre><code>flowchart TB\n    User((\"User/Browser\")) --&gt;|HTTP| API[API Gateway]\n\n    subgraph \"Kubernetes Cluster\"\n        subgraph \"Node 1\"\n            C1{{UI Container}}\n            C2{{Auth Container}}\n        end\n\n        subgraph \"Node 2\"\n            C3{{Payment Container}}\n            C4{{Product Container}}\n        end\n\n        subgraph \"Node 3\"\n            C5{{Notification Container}}\n            C6{{Analytics Container}}\n        end\n\n        subgraph \"Persistent Storage\"\n            DB1[(Auth DB)]\n            DB2[(Product DB)]\n            DB3[(Payment DB)]\n        end\n    end\n\n    API --&gt;|Routes request| C1\n    API --&gt;|Routes request| C2\n    API --&gt;|Routes request| C3\n    API --&gt;|Routes request| C4\n    API --&gt;|Routes request| C5\n    API --&gt;|Routes request| C6\n\n    C2 -.-&gt;|Read/Write| DB1\n    C3 -.-&gt;|Read/Write| DB3\n    C4 -.-&gt;|Read/Write| DB2\n\n    C1 &lt;--&gt;|API calls| C2\n    C1 &lt;--&gt;|API calls| C4\n    C3 &lt;--&gt;|API calls| C4</code></pre> <p>Tip</p> <p>Tools like Docker help create containers, while systems like Kubernetes help manage many containers.</p>"},{"location":"fundamentals/database/","title":"Database &amp; Storage","text":""},{"location":"fundamentals/database/#database-types","title":"Database Types","text":""},{"location":"fundamentals/database/#sql-database","title":"SQL Database","text":"<p>Relational database that uses structured query language for defining and manipulating data.</p> <p>Popular Implementations</p> <ul> <li>PostgreSQL</li> <li>MySQL</li> <li>SQL Server</li> <li>Oracle</li> </ul> <p>Best For</p> <p>Complex queries, transactions, and data with well-defined relationships</p>"},{"location":"fundamentals/database/#nosql-database","title":"NoSQL Database","text":"<p>Non-relational database designed for distributed data stores with diverse data models.</p> <p>Common Types</p> <ul> <li>Document stores: MongoDB, Couchbase</li> <li>Key-value stores: Redis, DynamoDB</li> <li>Column-family stores: Cassandra, HBase</li> <li>Graph databases: Neo4j, Amazon Neptune</li> </ul> <p>Best For</p> <p>Scalability, flexibility with unstructured data, high write throughput</p>"},{"location":"fundamentals/database/#tsdb-time-series-database","title":"TSDB (Time Series Database)","text":"<p>Database optimized for time-stamped or time series data.</p> <p>Popular Implementations</p> <ul> <li>InfluxDB</li> <li>TimescaleDB (PostgreSQL extension)</li> <li>Prometheus</li> </ul> <p>Best For</p> <p>Metrics, monitoring data, IoT sensor data, financial market data</p>"},{"location":"fundamentals/database/#data-partition","title":"Data Partition","text":""},{"location":"fundamentals/database/#partitioning-vertical-partitioning","title":"Partitioning (Vertical Partitioning)","text":"<p>Division of a database table into multiple tables by columns, with each table having fewer columns.</p> <p>Use Case</p> <ul> <li>Splitting a wide table with customer profile data, purchase history, and preferences into separate tables by data category</li> </ul>"},{"location":"fundamentals/database/#sharding-horizontal-partitioning","title":"Sharding (Horizontal Partitioning)","text":"<p>Database architecture pattern where rows of a database table are held separately in different database nodes.</p> <p>Common Sharding Strategies</p> <ul> <li>Range-based: Partition by ranges of a key (e.g., customer_id 1-1000, 1001-2000)</li> <li>Hash-based: Use a hash function on the key</li> <li>Directory-based: Maintain a lookup table mapping keys to shards</li> </ul>"},{"location":"fundamentals/database/#database-optimization","title":"Database Optimization","text":""},{"location":"fundamentals/database/#database-indexing","title":"Database Indexing","text":"<p>Data structure technique to improve the speed of data retrieval operations.</p> <p>Tradeoffs</p> <ul> <li>Indexes speed up reads but slow down writes and require additional storage</li> </ul> <p>Best Practices</p> <ul> <li>Index columns used in WHERE clauses and joins</li> <li>Avoid over-indexing</li> <li>Consider composite indexes for multi-column queries</li> </ul>"},{"location":"fundamentals/database/#denormalization","title":"Denormalization","text":"<p>Strategy to improve read performance by adding redundant data or grouping data.</p> <p>Techniques</p> <ul> <li>Materialized views</li> <li>Precomputed aggregates</li> <li>Redundant fields</li> </ul>"},{"location":"fundamentals/database/#storage-solutions","title":"Storage Solutions","text":""},{"location":"fundamentals/database/#blob-storage","title":"Blob Storage","text":"<p>System for storing large binary objects, such as images, videos, or documents.</p> <p>Services</p> <ul> <li>AWS S3</li> <li>Azure Blob Storage</li> <li>Google Cloud Storage</li> </ul> <p>Best For</p> <ul> <li>Unstructured data like media files, backups, and static website content</li> </ul>"},{"location":"fundamentals/networking/","title":"Networking &amp; Communication","text":""},{"location":"fundamentals/networking/#network-models","title":"Network Models","text":"<p>Describes how computer networks are organized and how their components interact.</p> TCP/IP ModelOSI Model <p>TCP/IP (Transmission Control Protocol/Internet Protocol) model is a conceptual and practical framework that organizes network communications into four layers:</p> <p>Layers</p> <ul> <li>Application Layer(1): Where applications and services operate (HTTP, FTP, SMTP)</li> <li>Transport Layer(2): Handles data transmission between hosts (TCP, UDP)</li> <li>Internet Layer(3): Manages addressing and routing of data packets</li> <li>Network Access/Link Layer(4): Handles physical connection to the network (Ethernet, WiFi)</li> </ul> <ol> <li>End-user services</li> <li>End-to-end data delivery</li> <li>Routing packets across networks</li> <li>Network interface</li> </ol> <p>OSI (Open Systems Interconnection) model is another conceptual framework that describes and breaks down network communication in seven layers:</p> <p>Layers</p> <ul> <li>Application Layer (L7): User interface and services (HTTP, HTTPS, FTP, SMTP, DNS)</li> <li>Presentation Layer (L6): Data translation, encryption, compression (SSL/TLS, JPEG, MPEG)</li> <li>Session Layer (L5): Connection management and synchronization (NetBIOS, RPC)</li> <li>Transport Layer (L4): End-to-end communication and error recovery (TCP, UDP)</li> <li>Network Layer (L3): Logical addressing and routing (IP, ICMP, OSPF)</li> <li>Data Link Layer (L2): Physical addressing and error detection (Ethernet, MAC, PPP)</li> <li>Physical Layer (L1): Physical transmission of raw bits (Cables, Hubs, Repeaters)</li> </ul> <p>Common Protocols</p> <ul> <li>Web: HTTP/HTTPS (Application)</li> <li>Email: SMTP (Application)</li> <li>File Transfer: FTP (Application)</li> <li>Reliable Data: TCP (Transport)</li> <li>Fast Data: UDP (Transport)</li> <li>Routing: IP (Network)</li> </ul>"},{"location":"fundamentals/networking/#network-addressing-identification","title":"Network Addressing &amp; Identification","text":""},{"location":"fundamentals/networking/#ip-addressing","title":"IP Addressing","text":"<p>Numerical label assigned to devices on a network using the Internet Protocol (IP), used to identify and locate them for communication.</p>"},{"location":"fundamentals/networking/#ipv4-and-ipv6","title":"IPv4 and IPv6","text":"<p>IPv4 and IPv6 are two versions of the Internet Protocol (IP) used to identify devices on a network.</p> <p>IPv4 Key Characteristics</p> <ul> <li>32-bit address format (4 bytes): Provides over 4.3 billion unique addresses (2^32)</li> <li>Dotted decimal notation: Addresses written as four 8-bit numbers separated by dots (e.g., 192.168.1.1), divided into network and host portions</li> <li>Address classes: Traditionally divided into classes A, B, C, D, and E (though modern networks use CIDR instead)</li> <li>Limited supply: The finite address space has led to IPv4 address exhaustion</li> <li>NAT dependency: Network Address Translation became necessary to extend the usable life of IPv4</li> </ul> <p>IPv6 Key Characteristics</p> <ul> <li>128-bit address format (16 bytes): Provides virtually unlimited addresses (2^128) to solve IPv4 address exhaustion</li> <li>Hexadecimal notation: Addresses written as eight 16-bit groups separated by colons (e.g., 2001:0db8:85a3:0000:0000:8a2e:0370:7334)</li> <li>Built-in security: Integrated IPsec support for authentication and encryption</li> <li>Auto-configuration: Supports stateless address auto-configuration (SLAAC)</li> <li>No NAT requirement: Designed to provide direct end-to-end connectivity without address translation</li> </ul>"},{"location":"fundamentals/networking/#subnets-and-cidr-notation","title":"Subnets and CIDR notation","text":"<p>Subnets and CIDR notation is about how networks are segmented. A subnet is a logical partition to divide a large network into smaller netowkr segments for improved security and performance, while CIDR notation uses format <code>IP_address/prefix_length</code> to represent subnet masks in IP addresses (e.g., 192.168.1.0/24).</p> <p>Example</p> <p>192.168.1.0/24</p> <ul> <li>192.168.1.0 is the network address and /24 is the subnet mask</li> <li>Subnet mask 24 means the first 24 bits are used for network identification, while the remaining 8 bits are used for host identification within the network</li> <li>Contains 254 usable addresses (192.168.1.1 to 192.168.1.254)</li> </ul>"},{"location":"fundamentals/networking/#public-vs-private-addresses","title":"Public vs Private addresses","text":"<p>Public IP addresses are globally routable and unique across the internet.</p> <p>Private IP addresses (10.x.x.x, 172.16-31.x.x, 192.168.x.x) are used within local networks and cannot be accessed directly from the internet without NAT (Network Address Translation).</p> <p>Note</p> <ul> <li>Every device has to have an IP address for communication purposes.</li> <li>Public IP address is unique and assigned by Internet Service Provides to give you access to the World Wide Web.</li> <li>Private IP address is only used internally (Home, business, etc) and needs to be conveted to public IP address to access the internet.</li> </ul>"},{"location":"fundamentals/networking/#loopback-addresses","title":"Loopback addresses","text":"<p>127.0.0.1 (IPv4) and ::1 (IPv6) are localhost IP addresses for local development.</p> <p>Special addresses (127.0.0.1 in IPv4 and ::1 in IPv6) that allow device to send network packets to itself. Essential for testing network services locally without using the physical network interface.</p>"},{"location":"fundamentals/networking/#dns-domain-name-system","title":"DNS (Domain Name System)","text":"<p>A system that translates domain names into IP addresses computers use to identify each other.</p> <p>Example</p> <ul> <li>When you enter \"example.com\" in a browser, DNS resolves this to an IP address like 93.184.216.34</li> </ul> <p>Common Record Types</p> <ul> <li>A Record: Maps hostname to IPv4 address</li> <li>CNAME: Canonical name record (alias)</li> <li>MX: Mail exchange record</li> <li>TXT: Text record, often used for verification</li> </ul>"},{"location":"fundamentals/networking/#resolution-process","title":"Resolution process","text":"<p>DNS resolution typically involves multiple steps to find the IP address for the domain.</p> <p>How does it work</p> <ol> <li>Browser first checks local DNS cache</li> <li>If not found, it queries a recursive DNS resolver (Provided by ISP)</li> <li>Resolver queries root servers, TLD nameservers, authoritative nameservers to find the IP address for the domain</li> <li>Caches the response and return the IP address to client</li> </ol> <p>This process is often cached at various levels to improve performance, based on the TTL.</p>"},{"location":"fundamentals/networking/#ttl-and-propagation","title":"TTL and propagation","text":"<p>TTL is a value assigned to each DNS record that determines how long that record can be cached before they must be refreshed.</p> <p>DNS propagation refers to the time required for updated DNS records to spread across all DNS servers globally, which can take from minutes to 48 hours depending on TTL settings.</p> <p>DNS propagation</p> <p>When you make DNS changes (like pointing your domain to a different server), the updates won't be fully propagated until the TTL expires. (1)</p> <ol> <li> When planning major DNS changes (like changing web hosts), it's common practice to:<ol> <li>Lower your TTL values to something small (like 300 seconds/5 minutes) a day or two before the change</li> <li>Make the DNS change</li> <li>Wait for the short TTL to expire globally</li> <li>Then increase the TTL back to a longer value (like 3600 or 86400 seconds)</li> </ol> </li> </ol>"},{"location":"fundamentals/networking/#local-host-files","title":"Local host files","text":"<p>Operating systems maintain a hosts file (1) that maps hostnames to IP addresses locally, bypassing DNS resolution. This file can be modified for testing, development, or blocking specific websites, and takes precedence over DNS lookups.</p> <ol> <li><code>/etc/hosts</code> on Linux/Mac or <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code> on Windows</li> </ol>"},{"location":"fundamentals/networking/#port-numbers","title":"Port Numbers","text":"<p>Logical endpoints for network communication that help computers distinguish between different services or applications running on the same IP address. (1)</p> <ol> <li>Think of an IP address as the address of a building, while port numbers identify specific rooms or offices within that building.</li> </ol> <p>Common Ports</p> <ul> <li>Web server (80/443): 192.168.1.10:80 (HTTP) or 192.168.1.10:443 (HTTPS)</li> <li>FTP server (21): 64.233.160.0:21</li> <li>SSH connection (22): 52.45.187.132:22</li> <li>SMTP mail server (25): smtp.example.com:25 (same as 192.168.2.5:25)</li> <li>DNS server (53): 8.8.8.8:53 (Google's DNS)</li> <li>Remote desktop (3389): 10.10.5.12:3389 (RDP)</li> <li>MySQL database (3306): 10.0.0.5:3306</li> <li>PostgreSQL server (5432): 172.16.254.1:5432</li> <li>MongoDB instance (27017): 192.168.0.100:27017</li> </ul>"},{"location":"fundamentals/networking/#socket","title":"Socket","text":"<p>A two-way communication endpoint that allows programs to exchange data over the network. A socket is bound to a port number so that the TCP layer can identify the application that data is destined to be sent to.</p> <p>Tip</p> <p>A socket address is the combination of IP address and port number: 192.168.1.5:80</p> <p>So How Does It Work Exacly?</p> <p>A typical example will be when you're using a web browser to visit a website:</p> <ol> <li>Application Initiates Connection: When you type \"www.example.com\" in your browser, your browser (the client) needs to create a network connection.</li> <li>Socket Creation: Your browser creates a socket - think of this as opening a communcation channel</li> <li>Client Port Assignment: Your OS automatically assigns your browser a random high-numbered port (like 49152-65535) as the source port.</li> <li>DNS Resolution: Your computer figures out the IP address for \"example.com\".</li> <li>Connection Establishment: Your browser uses its socket (Your IP address + Source Port) to connect to the web server at example.com on port 80/443 (standard HTTP/HTTPS port).</li> <li>On the Server Side: The web server at \"example.com\" already has a socket bound to port 80/443, activaly listening for incoming connections.</li> <li>Data Exchange: Your browser sends an HTTP request for the webpage, and the server sends back the content.</li> <li>Connection Termination: After receiving the webpage, the connection might be kept open for a while or closed, depending on settings.</li> </ol> <p>Port Biding</p> <p>For client applications:</p> <ul> <li>Typically don't bind to a specific port explictly</li> <li>The OS assigns them a random port during socket creation process</li> </ul> <p>For server applications (1):</p> <ul> <li>Explicitly bind to a specific, well-known port (like port 80 for HTTP or 443 for HTTPS) </li> <li>Choice of port depends on the type of application so the clients know where to connect</li> </ul> <ol> <li> For web applications: Actually the web server (like Apache, Nginx, or IIS) binds to port 80, not the individual web applications. When requests come in, the web server routes them to different applications.</li> </ol>"},{"location":"fundamentals/networking/#socket-types-and-states","title":"Socket Types and States","text":"<p>Socket Types</p> Stream SocketDatagram Socket <p>Connection-oriented sockets that use TCP for reliable, sequenced communication.</p> <p>Example: Web servers, file transfers, where data integrity is crucial</p> <p>Connectionless sockets that use UDP and don't guarantee reliable delivery.</p> <p>Example: DNS queries, streaming video, online gaming, where speed is more important</p> <p>Socket States</p> <p>Socket states can be defined as the different phases a network socket goes through during its lifecycle.</p> Stream Socket States (TCP-Specific)Datagram Socket States (UDP-Specific) <p>TCP sockets follow a complex state transition diagram throughout their connection lifecycle.</p> <p>UDP sockets have a much simpler state model:</p> <ul> <li>Bound: Socket has a local address and port assigned</li> <li>Connected: Socket filters to receive only from a specific address (not a true connection)</li> <li>Closed: Socket is no longer valid for communication</li> </ul>"},{"location":"fundamentals/networking/#data-packet","title":"Data Packet","text":"<p>A unit of data that is transferred over a network. Data sent over network is divided into packets, they are then reassembed by the device that received them.</p>"},{"location":"fundamentals/networking/#headers-and-encapsulation","title":"Headers and encapsulation","text":"<p>Encapsulation is the process of wrapping data chunks in layers of headers as it moves down the protocol stack.</p> <p>Headers are the information (protocol, source address, destination address,etc) added to the packet.</p> <p>Note</p> <p>If the orginal data is too large to  fit into a single packet, the data will be divided into multiple smaller chuncks. (1) Each of these chuncks will then go through the encapsulation process to become a data packet.</p> <p>How does it work?</p> <p>When you send information across a network:</p> <ol> <li>The original data (like text from a webpage) starts as raw content.</li> <li>The transport layer (TCP) divides large data into appropriate segments if needed</li> <li>As this data moves down through the network protocol stack, each layer adds its own header information (encapsulation):</li> <li>The application layer might format it as HTTP</li> <li>The transport layer (TCP/UDP) adds port information and sequence numbers</li> <li>The network layer (IP) adds source and destination IP addresses</li> <li>The link layer adds MAC addresses</li> <li>After complete encapsulation, if the packet exceeds the network's MTU, IP fragmentation occurs.</li> </ol> <ol> <li>This division typically happens at different layers: At the transport layer (TCP), large data is segmented into smaller pieces that fit within the Maximum Segment Size (MSS). After encapsulation, if packets are still too large, the network layer (IP) will perform further fragmentation.</li> </ol>"},{"location":"fundamentals/networking/#mtu-and-fragmentation","title":"MTU and Fragmentation","text":"<p>MTU: The largest packet size that can be sent over a network connection.</p> <p>Fragmentation: When a packet is larger than the MTU, it gets split into smaller fragments:</p> <ul> <li>Each fragment gets its own set of headers</li> <li>Fragments are reassembled at the destination</li> <li>The IP header contains information to help with reassembly</li> </ul> <p>Standard MTU Sizes</p> <ul> <li>Ethernet: 1500 bytes</li> <li>Wi-Fi: 1500 bytes</li> </ul> <p>Relationship between Encapsulation and Fragmentation</p> <ol> <li> <p>MTU Constraints: Each network link has an MTU limit. If after encapsulation a packet exceeds this limit, fragmentation becomes necessary.</p> </li> <li> <p>Header Overhead: Each layer's headers (added during encapsulation) reduce the amount of space available for actual data. For example, if MTU is 1500 bytes and headers take 40 bytes, only 1460 bytes remain for data (the MSS).</p> </li> <li> <p>Performance Impact: Fragmentation impacts network performance because:</p> <ul> <li>It increases overall overhead (each fragment needs its own complete headers)</li> <li>All fragments must arrive for reassembly (if one is lost, everything must be retransmitted)</li> <li>Reassembly requires extra processing and memory</li> </ul> </li> <li> <p>Path MTU Discovery: Modern networks use this technique to determine the smallest MTU along the entire path and limit packet sizes accordingly to avoid fragmentation.</p> </li> </ol>"},{"location":"fundamentals/networking/#transport-protocols","title":"Transport Protocols","text":"<p>Transport protocols enable communication between applications across networks, handling data delivery between endpoints. They manage how data is packaged, transmitted, received, and verified.</p> <p>TCP and UDP represent two fundamentally different approaches to network communication:</p> <ul> <li> <p>TCP: Prioritizes reliability and order at the cost of speed and overhead</p> </li> <li> <p>UDP: Prioritizes speed and simplicity at the cost of reliability guarantees</p> </li> </ul>"},{"location":"fundamentals/networking/#tcp","title":"TCP","text":"<p>A connection-oriented transport protocol that provides a reliable communication channel between devices over the internet with guaranteed delivery and ordered data transmission.</p>"},{"location":"fundamentals/networking/#connection-oriented-communication","title":"Connection-Oriented Communication","text":"<p>TCP establishes a dedicated connection through Three-way Handshake before exchanging data and ensures all packets arrive correctly.</p> <p>Three-Way Handshake</p> <p>A fundamental process to establish a reliable connection between a client and a server before data transmission begins. It's like a formal greeting ritual that happens in three steps:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: Connection Establishment\n    Client-&gt;&gt;Server: SYN (seq=x)\n    Note right of Client: Client sends SYN packet with initial sequence number\n    Server-&gt;&gt;Client: SYN-ACK (seq=y, ack=x+1)\n    Note left of Server: Server acknowledges client's SYN and sends its own SYN\n    Client-&gt;&gt;Server: ACK (seq=x+1, ack=y+1)\n    Note right of Client: Client acknowledges server's SYN\n    Note over Client,Server: Connection Established\n</code></pre> <ol> <li>SYN: The client initiates the connection by sending an SYN packet with client's sequence number (x)</li> <li>SYNC-ACK: The server responds with a SYN-ACK message to acknowledge the client's request and synchronize sequence numbers (server's sequence number (y) and client's sequence number + 1 (x+1))</li> <li>ACK: The client sends an ACK packet with server's sequence number + 1 (y+1) to establish the connection.</li> </ol> <p>Why Do We Need Three-Way Handshake?</p> <p>The three-way handshake is necessary because both parties need to confirm that they can send and receive messages properly.</p> <p> TCP Three-way Handshake Process </p>"},{"location":"fundamentals/networking/#tcp-socket-states","title":"TCP Socket States","text":"<p>TCP connections go through different states throughout their lifecycle.</p> State Description CLOSED The default state when no connection exists LISTEN The server is waiting for connection requests (only servers enter this state) SYN_SENT The client has sent a SYN packet and is waiting for a response SYN_RECEIVED The server has received a SYN and sent a SYN-ACK, waiting for the final ACK ESTABLISHED The three-way handshake is complete and data transfer can begin FIN_WAIT_1 The application has finished sending data and sent a FIN packet to start closing the connection FIN_WAIT_2 The local end has received acknowledgment of its FIN packet CLOSE_WAIT The remote end has initiated connection termination, and the local end needs to close too LAST_ACK The local end has sent its own FIN after receiving a FIN from the remote end TIME_WAIT Waiting to ensure the remote end received the acknowledgment of its FIN CLOSING Both sides initiated closing simultaneously <p>Key Characteristics</p> <ul> <li>Reliability: Acknowledgment and retransmission of lost packets</li> <li>Ordered Delivery: Sequence numbers ensure correct ordering</li> <li>Flow Control: Prevents overwhelming receiver with too much data</li> <li>Congestion Control: Adjusts transmission rate based on network conditions</li> <li>Error Detection: Checksum verification ensures data integrity</li> </ul> <p>Common TCP Use Cases</p> <ul> <li>Web browsing (HTTP/HTTPS)</li> <li>Email (SMTP, IMAP, POP3)</li> <li>File transfers (FTP, SFTP)</li> <li>Remote terminal access (SSH)</li> <li>Database connections</li> </ul>"},{"location":"fundamentals/networking/#udp","title":"UDP","text":"<p>A connectionless transport protocol that sends datagrams between applications without guaranteeing delivery, used for real-time applications where speed matters more than perfect reliability.</p>"},{"location":"fundamentals/networking/#connectionless-communication","title":"Connectionless Communication","text":"<p>UDP sends datagrams without establishing a dedicated connection, prioritizing speed over reliability.</p> <p>UDP Communication Flow</p> <p>In contrast to TCP's connection-oriented approach, UDP operates without formal connection between endpoints:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: Connectionless Communication\n    Client-&gt;&gt;Server: Datagram 1\n    Client-&gt;&gt;Server: Datagram 2\n    Client-&gt;&gt;Server: Datagram 3\n    Note right of Client: Datagrams sent without waiting for acknowledgment\n    Note left of Server: May arrive in any order, or not at all\n</code></pre> <ol> <li>No Handshake: Packets are sent immediately without connection establishment</li> <li>Stateless Communication: No connection state is maintained between endpoints</li> <li>Independent Packets: Each datagram handled independently (\"fire and forget\")</li> <li>No Order Guarantee: Packets may arrive in a different order than sent, with no mechanism to restore sequence</li> </ol>"},{"location":"fundamentals/networking/#udp-socket-states","title":"UDP Socket States","text":"<p>UDP sockets have a simplified state model compared to TCP:</p> <p><code>Simple Lifecycle: Create \u2192 Bind \u2192 Send/Receive \u2192 Close</code></p> State Description UNBOUND Socket created but not yet assigned to an address or port BOUND Socket assigned to a local address and port, ready for communication CONNECTED Socket filtered to receive only from a specific address (not true connection) CLOSED Socket is no longer valid and cannot be used for communication <p>Key Characteristics</p> <ul> <li>Message-Oriented: Preserves message boundaries</li> <li>Unreliable: No guaranteed delivery or acknowledgments</li> <li>Unordered: No sequence numbers or packet ordering</li> <li>Lightweight: Minimal header overhead (8 bytes)</li> <li>Broadcast/Multicast: Supports one-to-many communication patterns</li> <li>No Flow Control: Can send at any rate regardless of receiver capacity</li> </ul> <p>Common UDP Use Cases</p> <ul> <li>Domain Name System (DNS)</li> <li>Streaming media (audio/video)</li> <li>Voice over IP (VoIP)</li> <li>Online gaming</li> <li>IoT sensor data</li> <li>Network monitoring (SNMP)</li> </ul>"},{"location":"fundamentals/networking/#tcp-vs-udp","title":"TCP vs UDP","text":"Feature TCP UDP Connection Connection-oriented Connectionless Reliability Guaranteed delivery Best-effort delivery Ordering Maintains packet order No ordering guarantees Error checking Extensive Basic checksumming Speed Slower due to overhead Faster, minimal overhead Header size 20-60 bytes 8 bytes Congestion control Yes No Flow control Yes No Packet boundaries Stream-oriented (no boundaries) Message-oriented (preserves boundaries) Use cases Web, email, file transfer Streaming, gaming, DNS <p>TCP vs UDP: Stream-Oriented vs Message-Oriented</p> <ul> <li>TCP: You get a continuous flow of bytes, requiring you to add your own message boundaries</li> <li>UDP: You get distinct, separate messages with natural boundaries already preserved</li> </ul> <p>TCP (Stream-Oriented)</p> <p>TCP works like a continuous phone call where all words flow together:</p> <ul> <li>When you send three messages: \"Hello\", \"How are you?\", \"What's new?\"</li> <li>TCP delivers them as one continuous stream: \"HelloHow are you?What's new?\"</li> <li>Your app must add its own framing mechanism to know where messages begin and end</li> <li>Like adding delimiter characters after each message: <code>Hello\\nHow are you?\\nWhat's new?\\n</code></li> </ul> <p>UDP (Message-Oriented)</p> <p>UDP works like sending separate text messages:</p> <ul> <li>Send three messages: \"Hello\", \"How are you?\", \"What's new?\"</li> <li>UDP delivers them as three separate packages, boundaries intact</li> <li>Each message arrives independently, with clear start and end points</li> <li>No need to add extra markers - the packaging itself separates messages</li> </ul>"},{"location":"fundamentals/networking/#network-services-infrastructure","title":"Network Services &amp; Infrastructure","text":""},{"location":"fundamentals/networking/#dhcp-dynamic-host-configuration-protocol","title":"DHCP (Dynamic Host Configuration Protocol)","text":"<p>A network management protocol that automatically assigns IP addresses and other network configuration parameters to devices on a network.</p>"},{"location":"fundamentals/networking/#automatic-ip-configuration","title":"Automatic IP configuration","text":"<p>DHCP enables devices to obtain network configuration automatically without manual setup, including IP address, subnet mask, default gateway, and DNS server information.</p> <p>DHCP Benefits</p> <ul> <li>Eliminates manual configuration errors</li> <li>Facilitates device mobility across networks</li> <li>Centralizes IP address management</li> <li>Prevents IP address conflicts through centralized allocation</li> </ul> <p>DHCP Alternatives</p> <ul> <li>Static IP assignment: Manually configuring each device (common for servers)</li> <li>Link-local addressing: When DHCP fails, devices can self-assign addresses (169.254.x.x in IPv4)</li> <li>SLAAC: Stateless Address Autoconfiguration in IPv6 networks</li> </ul>"},{"location":"fundamentals/networking/#lease-process","title":"Lease process","text":"<p>The DHCP lease process involves a four-step message exchange between client and server to obtain network configuration parameters for a specific time period.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: DHCP Discovery Process\n    Client-&gt;&gt;Server: DHCPDISCOVER (broadcast)\n    Note right of Client: \"Who can give me an IP address?\"\n    Server-&gt;&gt;Client: DHCPOFFER (unicast)\n    Note left of Server: \"I can offer you 192.168.1.100\"\n    Client-&gt;&gt;Server: DHCPREQUEST (broadcast)\n    Note right of Client: \"I accept the offer of 192.168.1.100\"\n    Server-&gt;&gt;Client: DHCPACK (unicast)\n    Note left of Server: \"Confirmed! Here's your configuration\"</code></pre> <p>DHCP Transaction</p> <ol> <li>DHCPDISCOVER: Client broadcasts to find available DHCP servers</li> <li>DHCPOFFER: Server offers an IP address and configuration</li> <li>DHCPREQUEST: Client requests the offered address</li> <li>DHCPACK: Server acknowledges and finalizes the lease</li> </ol> <p>Lease Renewal</p> <ul> <li>IP addresses are leased for a specified time period (often 24 hours)</li> <li>Client attempts to renew at 50% of lease time (T1)</li> <li>If renewal fails, client tries to rebind at 87.5% of lease time (T2)</li> <li>If rebinding fails, client must restart the DHCP discovery process</li> </ul>"},{"location":"fundamentals/networking/#nat-network-address-translation","title":"NAT (Network Address Translation)","text":"<p>A method that allows multiple devices on a private network to connect to the internet using a single public IP address.</p>"},{"location":"fundamentals/networking/#how-private-networks-connect-to-the-internet","title":"How private networks connect to the internet","text":"<p>NAT maps private IP addresses to a public IP address by modifying network address information in packet headers.</p> <p>NAT Operation</p> <ol> <li>Outbound Traffic: </li> <li>Device sends packet from private IP (e.g., 192.168.1.5:3333)</li> <li>NAT router replaces source address with public IP (e.g., 203.0.113.5:5555)</li> <li>NAT creates a translation table entry mapping the connection</li> <li> <p>Modified packet is forwarded to the internet</p> </li> <li> <p>Inbound Traffic:</p> </li> <li>Response comes back to public IP (203.0.113.5:5555)</li> <li>NAT router looks up mapping in translation table</li> <li>Destination address is changed back to private IP (192.168.1.5:3333)</li> <li>Packet is forwarded to the internal device</li> </ol> <p>NAT Types</p> <ul> <li>Source NAT (SNAT): Modifies source address in outgoing packets (most common)</li> <li>Destination NAT (DNAT): Modifies destination address in incoming packets (for port forwarding)</li> <li>Port Address Translation (PAT): Uses different ports to distinguish connections (also called NAPT)</li> </ul>"},{"location":"fundamentals/networking/#nat-types-and-challenges","title":"NAT types and challenges","text":"<p>Different NAT implementations vary in restrictiveness, affecting connectivity for certain applications.</p> <p>NAT Classifications</p> <ul> <li>Full-cone NAT: Most permissive - any external host can send to an internal client once a connection is established</li> <li>Address-restricted cone: Only allows incoming traffic from IPs that the internal host has previously sent traffic to</li> <li>Port-restricted cone: Only allows incoming traffic from specific IP:port combinations that the internal host has communicated with</li> <li>Symmetric NAT: Most restrictive - uses different external ports for each destination, challenging for peer-to-peer applications</li> </ul> <p>NAT Traversal Challenges</p> <ul> <li>Peer-to-peer (P2P) connections: Difficult when both peers are behind NAT</li> <li>Server-client model disruption: External hosts can't initiate connections to NAT-hidden services</li> <li>Protocol incompatibility: Some protocols embed IP addresses in payload (e.g., FTP, SIP)</li> <li>IPv6 transition: NAT was a short-term solution for IPv4 exhaustion</li> </ul> <p>NAT Traversal Techniques</p> <ul> <li>STUN (Session Traversal Utilities for NAT): Helps discover NAT type and external IP/port</li> <li>TURN (Traversal Using Relays around NAT): Uses relay server for restrictive NATs</li> <li>ICE (Interactive Connectivity Establishment): Framework combining STUN, TURN, and direct connectivity</li> <li>UPnP/NAT-PMP: Protocols allowing applications to configure port forwarding automatically</li> </ul>"},{"location":"fundamentals/networking/#routing","title":"Routing","text":"<p>The process of selecting paths in a network along which to send network traffic.</p>"},{"location":"fundamentals/networking/#routing-tables-and-protocols","title":"Routing tables and protocols","text":"<p>Routing tables contain information about network destinations and how to reach them, while routing protocols are the methods by which routers share information to build these tables.</p> <p>Simplified Routing Table</p> Destination Network Subnet Mask Next Hop Interface Metric 192.168.1.0 255.255.255.0 0.0.0.0 eth0 0 10.0.0.0 255.0.0.0 192.168.1.254 eth0 10 0.0.0.0 0.0.0.0 192.168.1.1 eth0 1 <p>Routing Process</p> <p>When a router receives a packet:</p> <ol> <li>Extract the destination IP address</li> <li>Look for the longest matching prefix in the routing table</li> <li>Forward the packet to the next hop or directly to the destination</li> <li>If no match is found, send to the default gateway (if configured)</li> </ol>"},{"location":"fundamentals/networking/#default-gateways","title":"Default gateways","text":"<p>A default gateway is the node (typically a router) that serves as an access point to other networks when no specific route matches the destination.</p> <p>Note</p> <ul> <li>Default route is represented as 0.0.0.0/0 in routing tables</li> <li>It's used as a \"last resort\" when no more specific route exists</li> <li>In home/office networks, the default gateway connects the local network to the internet</li> <li>Without a default gateway, devices can only communicate within their local network</li> </ul> <p>Example</p> <p>For a device with IP 192.168.1.100 and subnet mask 255.255.255.0:</p> <ul> <li>Can directly reach addresses 192.168.1.1 through 192.168.1.254</li> <li>Must use default gateway (typically 192.168.1.1) to reach any other address</li> </ul>"},{"location":"fundamentals/networking/#autonomous-systems","title":"Autonomous systems","text":"<p>An Autonomous System (AS) is a collection of connected IP networks under the control of a single organization that presents a common routing policy to the internet.</p> <p>AS Characteristics</p> <ul> <li>Identified by a unique Autonomous System Number (ASN)</li> <li>Typically operated by ISPs or large organizations</li> <li>Interior routing occurs within an AS (using protocols like OSPF, EIGRP)</li> <li>Exterior routing occurs between different ASes (using BGP)</li> </ul> <p>Example</p> <ul> <li>Google's AS number is AS15169</li> <li>Comcast uses AS7922</li> <li>Amazon Web Services uses multiple ASNs including AS16509</li> </ul>"},{"location":"fundamentals/networking/#routing-protocols-how-routers-learn-paths-bgp-ospf-etc","title":"Routing protocols: How routers learn paths (BGP, OSPF, etc.)","text":"<p>Routing protocols enable routers to dynamically discover and share information about network topologies.</p> <p>Interior vs. Exterior Protocols</p> Interior Gateway Protocols (IGP)Exterior Gateway Protocols (EGP) <p>Used within an autonomous system:</p> <ul> <li>OSPF (Open Shortest Path First): Link-state protocol that calculates shortest path first using Dijkstra's algorithm</li> <li>IS-IS (Intermediate System to Intermediate System): Similar to OSPF, used in large service provider networks</li> <li>RIP (Routing Information Protocol): Simple distance-vector protocol with hop count as metric (limited to 15 hops)</li> <li>EIGRP (Enhanced Interior Gateway Routing Protocol): Cisco's advanced distance-vector protocol</li> </ul> <p>Used between autonomous systems:</p> <ul> <li>BGP (Border Gateway Protocol): The routing protocol of the internet, makes decisions based on paths, policies, and rule-sets rather than just metrics</li> </ul> <p>Routing Protocol Selection Factors</p> <ul> <li>Network size and complexity</li> <li>Convergence speed requirements</li> <li>Administrative boundaries</li> <li>Hardware capabilities</li> <li>Scalability needs</li> </ul>"},{"location":"fundamentals/networking/#proxies-intermediaries","title":"Proxies &amp; Intermediaries","text":"<p>Network components that mediate connections between clients and servers.</p>"},{"location":"fundamentals/networking/#forward-proxies","title":"Forward proxies","text":"<p>A forward proxy sits between client devices and the internet, forwarding client requests to web servers.</p> <p>Forward Proxy Features</p> <ul> <li>Client must be configured to use the proxy</li> <li>Can provide anonymity by hiding client's real IP address</li> <li>Enables access control, content filtering, and usage policies</li> <li>Can cache resources to improve performance</li> </ul> <p>Common Forward Proxy Uses</p> <ul> <li>Corporate networks restricting employee internet access</li> <li>Schools filtering inappropriate content</li> <li>Bypassing geo-restrictions (VPN services often function as proxies)</li> <li>Anonymizing web browsing</li> </ul>"},{"location":"fundamentals/networking/#reverse-proxies","title":"Reverse proxies","text":"<p>A reverse proxy sits in front of web servers and forwards client requests to appropriate backend servers.</p> <p>Reverse Proxy Features</p> <ul> <li>Client interacts with the proxy believing it's the actual server</li> <li>Distributes client requests across multiple servers</li> <li>Provides additional security by hiding backend server details</li> <li>Can handle SSL/TLS encryption/decryption (SSL termination)</li> <li>Enables caching and compression of responses</li> </ul> <p>Common Reverse Proxy Uses</p> <ul> <li>Load balancing across multiple application servers</li> <li>Web application firewalls</li> <li>Content caching</li> <li>Handling SSL/TLS termination</li> </ul>"},{"location":"fundamentals/networking/#load-balancers","title":"Load balancers","text":"<p>A load balancer distributes incoming network traffic across multiple servers to ensure high availability and reliability.</p> <p>Load Balancing Methods</p> <ul> <li>Round Robin: Requests distributed sequentially to each server</li> <li>Least Connections: Requests sent to server with fewest active connections</li> <li>Least Response Time: Requests sent to server with fastest response time</li> <li>IP Hash: Client IP determines which server receives the request (session persistence)</li> <li>Weighted: Servers assigned different weights based on capacity</li> </ul> <p>Load Balancer Types</p> <ul> <li>Layer 4 (Transport): Decisions based on IP address and port</li> <li>Layer 7 (Application): Content-aware, can route based on URL, HTTP headers, cookies</li> <li>Hardware: Purpose-built appliances (e.g., F5, Citrix)</li> <li>Software: Applications running on standard servers (e.g., NGINX, HAProxy)</li> <li>Cloud-based: Managed services (e.g., AWS ELB, Google Cloud Load Balancing)</li> </ul>"},{"location":"fundamentals/networking/#firewalls-network-security","title":"Firewalls &amp; Network Security","text":"<p>Network security devices that monitor and filter incoming and outgoing network traffic based on security rules.</p>"},{"location":"fundamentals/networking/#traffic-filtering","title":"Traffic filtering","text":"<p>Firewalls filter traffic based on predefined security rules to protect networks from unauthorized access and threats.</p> <p>Firewall Filtering Criteria</p> <ul> <li>Source and destination IP addresses</li> <li>Port numbers</li> <li>Protocol types (TCP, UDP, ICMP)</li> <li>Application-specific data (for advanced firewalls)</li> <li>Time of day</li> <li>User identity (in next-gen firewalls)</li> </ul> <p>Firewall Types</p> <ul> <li>Packet Filtering Firewalls: Basic firewalls examining packet headers</li> <li>Circuit-Level Gateways: Monitor TCP handshakes and sessions</li> <li>Application-Level Gateways (Proxies): Inspect application-layer data</li> <li>Stateful Inspection Firewalls: Track the state of active connections</li> <li>Next-Generation Firewalls (NGFW): Combine traditional firewall with additional functionality (IPS, deep packet inspection)</li> </ul>"},{"location":"fundamentals/networking/#stateful-vs-stateless-inspection","title":"Stateful vs stateless inspection","text":"<p>The primary distinction between stateful and stateless firewalls is whether they track the state of active network connections.</p> <p>Stateless Inspection</p> <ul> <li>Examines each packet in isolation</li> <li>Uses static rules based on source/destination addresses and ports</li> <li>Doesn't keep track of connection state</li> <li>Faster but less secure</li> <li>Vulnerable to IP spoofing and certain attacks</li> </ul> <p>Stateful Inspection</p> <ul> <li>Tracks the state of active connections in a state table</li> <li>Understands the context of traffic based on previous packets</li> <li>Can determine if a packet is part of an existing connection</li> <li>More secure but requires more resources</li> <li>Can prevent many types of attacks by validating connection sequences</li> </ul> <p>Stateful Firewall Operation</p> <ol> <li>Outbound request creates an entry in the state table</li> <li>Inbound responses are checked against this table</li> <li>Packets that match known connections are allowed</li> <li>Packets claiming to be responses but without matching entries are blocked</li> </ol>"},{"location":"fundamentals/networking/#performance-metrics","title":"Performance Metrics","text":"<p>Key measurements that help evaluate network performance and identify issues.</p>"},{"location":"fundamentals/networking/#latency","title":"Latency","text":"<p>The time delay between a request being sent and the response being received, often measured in milliseconds.</p> <p>Latency Components</p> <ul> <li>Propagation delay: Time for signal to travel from source to destination (limited by speed of light)</li> <li>Transmission delay: Time to push all the packet's bits onto the link</li> <li>Processing delay: Time spent handling the packet inside devices</li> <li>Queuing delay: Time spent waiting in buffers for processing</li> </ul> <p>Typical Values</p> <ul> <li>Low latency: &lt; 100ms</li> <li>Medium latency: 100-300ms</li> <li>High latency: &gt; 300ms</li> </ul> <p>Impact on Applications</p> <ul> <li>Web browsing: Pages load slower with high latency</li> <li>Real-time audio/video: Noticeable delays in conversation</li> <li>Online gaming: Character/gameplay lag</li> <li>Financial trading: Missed opportunities with millisecond delays</li> </ul>"},{"location":"fundamentals/networking/#throughput","title":"Throughput","text":"<p>The amount of data that can be transferred from one point to another in a given time period.</p> <p>Throughput vs. Bandwidth</p> <ul> <li>Bandwidth is the theoretical capacity of the connection</li> <li>Throughput is the actual amount of data transferred</li> <li>Throughput is almost always lower than bandwidth due to protocol overhead, latency, network congestion, etc.</li> </ul> <p>Common Units</p> <ul> <li>Kbps (Kilobits per second)</li> <li>Mbps (Megabits per second)</li> <li>Gbps (Gigabits per second)</li> </ul> <p>Factors Affecting Throughput</p> <ul> <li>Network congestion</li> <li>Protocol overhead</li> <li>Device limitations</li> <li>Application design</li> <li>Distance and physical media</li> <li>TCP window size</li> </ul>"},{"location":"fundamentals/networking/#bandwidth","title":"Bandwidth","text":"<p>The maximum data transfer rate of a network or internet connection.</p> <p>Typical Values</p> <ul> <li>Home broadband: 25-1000 Mbps</li> <li>Business connections: 100 Mbps to 10+ Gbps</li> <li>Data center connections: Multiple 10/40/100 Gbps links</li> </ul> <p>Bandwidth Requirements</p> Application Typical Minimum Bandwidth Web browsing 1-5 Mbps SD video streaming 3-5 Mbps HD video streaming 5-10 Mbps 4K video streaming 25-50 Mbps Video conferencing 1-6 Mbps Online gaming 3-25 Mbps File downloads Varies with urgency"},{"location":"fundamentals/networking/#packet-loss","title":"Packet Loss","text":"<p>Percentage of packets that fail to reach their destination.</p> <p>Causes of Packet Loss</p> <ul> <li>Network congestion</li> <li>Hardware failures</li> <li>Software bugs</li> <li>Signal interference (wireless)</li> <li>Oversaturated network devices</li> <li>Security issues (firewall drops)</li> </ul> <p>Impact</p> <ul> <li>&lt;1%: Generally acceptable</li> <li>1-2.5%: Noticeable impact on real-time applications</li> <li>&gt;3%: Significant degradation in service quality</li> </ul> <p>Detecting Packet Loss</p> <pre><code>$ ping -c 100 example.com | grep -o -P '\\d+(?=% packet loss)'\n0\n</code></pre> <p>A value of 0 indicates no packet loss during the test.</p>"},{"location":"fundamentals/networking/#jitter","title":"Jitter","text":"<p>Variation in the delay of received packets.</p> <p>Why Jitter Matters</p> <ul> <li>Creates uneven delivery of real-time data</li> <li>Causes stuttering in voice/video</li> <li>Affects timing-sensitive applications</li> <li>Less important for web browsing, file transfers</li> </ul> <p>Acceptable Values</p> <ul> <li>&lt;30ms: Good for VoIP and video calling</li> <li>&gt;30ms: May cause quality issues in real-time communications</li> </ul> <p>Reducing Jitter Impact</p> <ul> <li>Jitter buffers in real-time applications</li> <li>Quality of Service (QoS) configurations</li> <li>Consistent network paths</li> <li>Adequate bandwidth provision</li> </ul>"},{"location":"fundamentals/networking/#network-troubleshooting","title":"Network Troubleshooting","text":""},{"location":"fundamentals/networking/#common-diagnostic-tools","title":"Common diagnostic tools","text":"<p>Network diagnostic tools help identify and resolve connectivity, performance, and configuration issues.</p> <p>Essential Diagnostic Tools</p> <ul> <li>ping: Tests basic connectivity and measures round-trip time</li> <li>traceroute/tracert: Displays the path packets take to a destination</li> <li>nslookup/dig: Queries DNS servers to resolve domain names</li> <li>ipconfig/ifconfig: Displays network interface configurations</li> <li>netstat/ss: Shows active network connections and listening ports</li> <li>tcpdump/Wireshark: Captures and analyzes network packets</li> <li>nmap: Network scanning and security auditing</li> <li>curl/wget: Tests HTTP/HTTPS connections and downloads</li> <li>iperf: Measures network performance (bandwidth, packet loss)</li> <li>mtr: Combines ping and traceroute for continuous monitoring</li> </ul> <p>Using Diagnostic Tools</p> Ping ExampleTraceroute Example <pre><code>$ ping example.com\nPING example.com (93.184.216.34): 56 data bytes\n64 bytes from 93.184.216.34: icmp_seq=0 ttl=56 time=11.632 ms\n64 bytes from 93.184.216.34: icmp_seq=1 ttl=56 time=11.726 ms\n64 bytes from 93.184.216.34: icmp_seq=2 ttl=56 time=10.683 ms\n</code></pre> <p>Indicates: Successful connectivity with ~11ms latency</p> <pre><code>$ traceroute example.com\ntraceroute to example.com (93.184.216.34), 64 hops max\n1  router.local (192.168.1.1)  1.170 ms  0.882 ms  0.798 ms\n2  isp-gateway.net (203.0.113.1)  12.616 ms  14.714 ms  15.494 ms\n3  isp-core-1.net (198.51.100.5)  15.746 ms  17.586 ms  16.003 ms\n4  internet-backbone.net (198.51.100.25)  20.853 ms  17.538 ms  18.012 ms\n5  example-edge.net (93.184.216.1)  19.125 ms  18.741 ms  18.294 ms\n6  example.com (93.184.216.34)  22.333 ms  21.496 ms  21.146 ms\n</code></pre> <p>Indicates: The route takes 6 hops with potential bottleneck at hop 4</p>"},{"location":"fundamentals/networking/#typical-network-issues","title":"Typical network issues","text":"<p>Common network problems encountered in software development and system administration.</p> <p>Common Network Issues</p> <ul> <li>Connectivity failures: Complete inability to reach a service or resource</li> <li>High latency: Excessive delays in data transmission</li> <li>Packet loss: Data packets never reaching their destination</li> <li>DNS resolution problems: Inability to convert domain names to IP addresses</li> <li>Routing issues: Inefficient or incorrect paths through the network</li> <li>Firewall blockages: Security configurations preventing legitimate traffic</li> <li>MTU mismatches: Packet fragmentation or black-holing</li> <li>Bandwidth saturation: Network congestion causing slowdowns</li> <li>Authentication failures: Issues with access credentials</li> <li>Certificate errors: Problems with TLS/SSL certificates or validation</li> </ul> <p>Symptom-Cause Correlation</p> Symptom Potential Causes Initial Investigation Can't reach website DNS error, connectivity issue, server down ping IP address, check DNS resolution Intermittent connection Packet loss, routing issues, interference ping with flood option, check for pattern Slow performance Latency, bandwidth limitations, server overload Run traceroute, check bandwidth usage Connection timeouts Firewall blocking, server not responding, misrouting Check firewall logs, verify server status"},{"location":"fundamentals/networking/#debugging-approaches","title":"Debugging approaches","text":"<p>Systematic methods for identifying, isolating, and resolving network problems.</p> <p>Network Troubleshooting Methodology</p> <ol> <li>Identify the problem: Clearly define the issue and its symptoms</li> <li>Gather information: Collect relevant data about the network environment</li> <li>Analyze the OSI layers systematically: Start from physical layer and move up</li> <li>Isolate the issue: Determine which component or segment is causing the problem</li> <li>Implement a solution: Make necessary changes to resolve the issue</li> <li>Verify the fix: Confirm the problem is resolved</li> <li>Document the solution: Record the issue and resolution for future reference</li> </ol> <p>OSI Layer Troubleshooting Approach</p> Physical &amp; Data Link (L1-L2)Network &amp; Transport (L3-L4)Session &amp; Above (L5-L7) <ul> <li>Check cables, connections, interface status</li> <li>Verify link lights, interface errors, duplex mismatches</li> <li>Commands: <code>ifconfig</code>/<code>ipconfig</code>, <code>ethtool</code>, check hardware</li> </ul> <ul> <li>Verify IP configuration, routing, and connectivity</li> <li>Test basic connectivity and trace packet path</li> <li>Commands: <code>ping</code>, <code>traceroute</code>, <code>route</code>, <code>netstat</code>/<code>ss</code></li> </ul> <ul> <li>Check application configuration, ports, and services</li> <li>Test specific services and application functionality</li> <li>Commands: <code>telnet</code>, <code>nslookup</code>/<code>dig</code>, <code>curl</code>, application logs</li> </ul> <p>Divide and Conquer Approach</p> <p>For a web application connectivity issue:</p> <ol> <li>Can the client reach anything on the internet? (Test with <code>ping 8.8.8.8</code>)</li> <li>Can the client resolve DNS? (Test with <code>nslookup example.com</code>)</li> <li>Can the client reach the web server? (Test with <code>ping web-server-ip</code>)</li> <li>Is the web server listening on the expected port? (Test with <code>telnet web-server-ip 80</code>)</li> <li>Is there an application-specific error? (Check HTTP status codes, application logs)</li> </ol> <p>Advanced Debugging Techniques</p> <ul> <li>Packet Capture Analysis: Use Wireshark/tcpdump to inspect actual packets</li> <li>Network Baselining: Compare current performance to established baselines</li> <li>Configuration Comparison: Compare working vs. non-working configurations</li> <li>Control Environment Testing: Test in a simplified environment to rule out variables</li> <li>Log Correlation: Analyze logs from multiple devices to identify patterns</li> </ul>"},{"location":"fundamentals/reliability/","title":"Reliability &amp; Consistency","text":""},{"location":"fundamentals/reliability/#consistency-models","title":"Consistency Models","text":""},{"location":"fundamentals/reliability/#acid-properties","title":"ACID Properties","text":"<p>Set of database transaction properties (Atomicity, Consistency, Isolation, Durability) that guarantee valid transactions.</p> <p>Components</p> <ul> <li>Atomicity: Transactions are all-or-nothing</li> <li>Consistency: Transactions bring the database from one valid state to another</li> <li>Isolation: Concurrent transactions don't interfere with each other</li> <li>Durability: Committed transactions persist even after system failures</li> </ul>"},{"location":"fundamentals/reliability/#base-properties","title":"BASE Properties","text":"<p>Alternative to ACID for distributed systems: Basically Available, Soft state, Eventually consistent.</p> <p>Components</p> <ul> <li>Basically Available: System guarantees availability</li> <li>Soft state: State may change over time without input</li> <li>Eventually consistent: System will become consistent over time</li> </ul>"},{"location":"fundamentals/reliability/#cap-theorem","title":"CAP Theorem","text":"<p>States that distributed systems can provide at most two of three guarantees: Consistency, Availability, and Partition tolerance.</p> <p>System Classifications</p> <ul> <li>CP (Consistent, Partition-tolerant): MongoDB, HBase</li> <li>AP (Available, Partition-tolerant): Cassandra, DynamoDB</li> <li>CA (Consistent, Available): Traditional RDBMS (not partition-tolerant)</li> </ul>"},{"location":"fundamentals/reliability/#reliability-patterns","title":"Reliability Patterns","text":""},{"location":"fundamentals/reliability/#failover","title":"Failover","text":"<p>Backup operational mode where functions are automatically transferred to standby system components.</p> <p>Types</p> <ul> <li>Active-passive: Standby server only activates when primary fails</li> <li>Active-active: Multiple servers handle traffic, survivors take over on failure</li> </ul>"},{"location":"fundamentals/reliability/#redundancy","title":"Redundancy","text":"<p>Duplication of critical components to increase reliability.</p> <p>Types</p> <ul> <li>Hardware redundancy: Multiple physical components</li> <li>Software redundancy: Multiple instances of software</li> <li>Data redundancy: Multiple copies of data</li> </ul>"},{"location":"fundamentals/reliability/#circuit-breaker","title":"Circuit Breaker","text":"<p>Pattern that prevents cascading failures by stopping requests to failing services.</p> <p>States</p> <ul> <li>Closed: Normal operation</li> <li>Open: Stops all requests</li> <li>Half-Open: Allows limited requests to test recovery</li> </ul>"},{"location":"fundamentals/reliability/#fault-tolerance","title":"Fault Tolerance","text":""},{"location":"fundamentals/reliability/#error-handling","title":"Error Handling","text":"<p>Strategies for managing and recovering from errors.</p> <p>Best Practices</p> <ul> <li>Graceful degradation</li> <li>Automatic retries</li> <li>Fallback mechanisms</li> <li>Comprehensive logging</li> </ul>"},{"location":"fundamentals/reliability/#recovery-strategies","title":"Recovery Strategies","text":"<p>Methods for restoring system functionality after failures.</p> <p>Approaches</p> <ul> <li>Rollback: Revert to previous stable state</li> <li>Rollforward: Apply changes to reach desired state</li> <li>Checkpointing: Save system state at regular intervals</li> </ul>"},{"location":"fundamentals/reliability/#high-availability","title":"High Availability","text":""},{"location":"fundamentals/reliability/#availability-metrics","title":"Availability Metrics","text":"<p>Measurements of system reliability and uptime.</p> <p>Common Metrics</p> <ul> <li>99.9% (Three nines): 8.76 hours downtime per year</li> <li>99.99% (Four nines): 52.56 minutes downtime per year</li> <li>99.999% (Five nines): 5.26 minutes downtime per year</li> </ul>"},{"location":"fundamentals/reliability/#ha-patterns","title":"HA Patterns","text":"<p>Design patterns for achieving high availability.</p> <p>Common Patterns</p> <ul> <li>Active-Active: Multiple active instances</li> <li>Active-Passive: One active, one or more standby</li> <li>Geographic redundancy: Multiple data centers</li> <li>Load balancing: Distribute traffic across instances</li> </ul>"},{"location":"fundamentals/reliability/#data-consistency","title":"Data Consistency","text":""},{"location":"fundamentals/reliability/#consistency-levels","title":"Consistency Levels","text":"<p>Different guarantees about data consistency.</p> <p>Types</p> <ul> <li>Strong consistency: All reads see latest write</li> <li>Eventual consistency: Reads eventually see latest write</li> <li>Causal consistency: Preserves cause-effect relationships</li> <li>Read-your-writes: User sees their own writes</li> </ul>"},{"location":"fundamentals/reliability/#consistency-patterns","title":"Consistency Patterns","text":"<p>Approaches to maintaining data consistency.</p> <p>Common Patterns</p> <ul> <li>Two-phase commit: Distributed transaction protocol</li> <li>Quorum-based: Majority of replicas must agree</li> <li>Version vectors: Track updates across replicas</li> <li>Conflict resolution: Handle concurrent updates</li> </ul>"},{"location":"fundamentals/scalability/","title":"Scalability &amp; Performance","text":""},{"location":"fundamentals/scalability/#scaling-strategies","title":"Scaling Strategies","text":""},{"location":"fundamentals/scalability/#vertical-scaling","title":"Vertical Scaling","text":"<p>Increasing the capacity of a single server by adding more resources (CPU, RAM).</p> <p>Pros and Cons</p> <ul> <li>Pros: Simple, no distribution complexity</li> <li>Cons: Limited by hardware capacity, expensive at high end</li> </ul>"},{"location":"fundamentals/scalability/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>Adding more machines to a system to handle increased load, distributing processing across multiple servers.</p> <p>Pros and Cons</p> <ul> <li>Pros: Linear cost scaling, high availability, fault tolerance</li> <li>Cons: Increased complexity, data consistency challenges</li> </ul>"},{"location":"fundamentals/scalability/#performance-optimization","title":"Performance Optimization","text":""},{"location":"fundamentals/scalability/#replication","title":"Replication","text":"<p>Process of creating and maintaining duplicate copies of data across multiple nodes.</p> <p>Types</p> <ul> <li>Master-slave: One primary write node, multiple read replicas</li> <li>Multi-master: Multiple nodes accept writes</li> <li>Peer-to-peer: All nodes are equal</li> </ul>"},{"location":"fundamentals/scalability/#caching","title":"Caching","text":"<p>Temporary storage of copies of data to reduce retrieval time and server load.</p> <p>Caching Levels</p> <ul> <li>Client-side: Browser cache, mobile app cache</li> <li>CDN caching: Edge locations</li> <li>Application caching: In-memory caches like Redis</li> <li>Database caching: Query cache, buffer pool</li> </ul>"},{"location":"fundamentals/scalability/#load-balancing","title":"Load Balancing","text":""},{"location":"fundamentals/scalability/#load-balancer-types","title":"Load Balancer Types","text":"<p>Different approaches to distributing traffic across servers.</p> <p>Common Types</p> <ul> <li>Round Robin: Distributes requests sequentially</li> <li>Least Connections: Sends to server with fewest active connections</li> <li>IP Hash: Routes based on client IP</li> <li>Weighted: Assigns different weights to servers</li> </ul>"},{"location":"fundamentals/scalability/#load-balancer-features","title":"Load Balancer Features","text":"<p>Key capabilities of load balancers.</p> <p>Important Features</p> <ul> <li>Health checking</li> <li>SSL termination</li> <li>Session persistence</li> <li>Request routing</li> <li>Traffic monitoring</li> </ul>"},{"location":"fundamentals/scalability/#performance-metrics","title":"Performance Metrics","text":""},{"location":"fundamentals/scalability/#response-time","title":"Response Time","text":"<p>Time taken for a system to respond to a request.</p> <p>Components</p> <ul> <li>Network latency: Time for data to travel</li> <li>Processing time: Time for server to process request</li> <li>Database time: Time for database operations</li> </ul>"},{"location":"fundamentals/scalability/#throughput","title":"Throughput","text":"<p>Number of requests a system can handle per unit time.</p> <p>Measurement</p> <ul> <li>Requests per second (RPS)</li> <li>Transactions per second (TPS)</li> <li>Queries per second (QPS)</li> </ul>"},{"location":"fundamentals/scalability/#resource-utilization","title":"Resource Utilization","text":"<p>How efficiently system resources are being used.</p> <p>Key Metrics</p> <ul> <li>CPU usage</li> <li>Memory usage</li> <li>Disk I/O</li> <li>Network bandwidth</li> </ul>"},{"location":"fundamentals/scalability/#scaling-patterns","title":"Scaling Patterns","text":""},{"location":"fundamentals/scalability/#sharding","title":"Sharding","text":"<p>Horizontal partitioning of data across multiple databases.</p> <p>Strategies</p> <ul> <li>Range-based: Partition by value ranges</li> <li>Hash-based: Use hash function on key</li> <li>Directory-based: Lookup table for shard location</li> </ul>"},{"location":"fundamentals/scalability/#partitioning","title":"Partitioning","text":"<p>Dividing data into smaller, more manageable pieces.</p> <p>Types</p> <ul> <li>Vertical: Split by columns</li> <li>Horizontal: Split by rows</li> <li>Functional: Split by business function</li> </ul>"},{"location":"fundamentals/scalability/#performance-optimization-techniques","title":"Performance Optimization Techniques","text":""},{"location":"fundamentals/scalability/#database-optimization","title":"Database Optimization","text":"<p>Techniques to improve database performance.</p> <p>Strategies</p> <ul> <li>Indexing</li> <li>Query optimization</li> <li>Connection pooling</li> <li>Denormalization</li> </ul>"},{"location":"fundamentals/scalability/#application-optimization","title":"Application Optimization","text":"<p>Methods to enhance application performance.</p> <p>Approaches</p> <ul> <li>Code profiling</li> <li>Memory management</li> <li>Asynchronous processing</li> <li>Batch processing</li> </ul>"},{"location":"fundamentals/security/","title":"Security Fundamentals","text":""},{"location":"fundamentals/security/#authentication-authorization","title":"Authentication &amp; Authorization","text":""},{"location":"fundamentals/security/#authentication","title":"Authentication","text":"<p>Process of verifying the identity of a user or system.</p> <p>Common Methods</p> <ul> <li>Password-based: Username/password combinations</li> <li>Multi-factor (MFA): Multiple verification methods</li> <li>OAuth/OpenID Connect: Third-party authentication</li> <li>JWT: JSON Web Tokens for stateless authentication</li> </ul>"},{"location":"fundamentals/security/#authorization","title":"Authorization","text":"<p>Process of determining what resources a user can access and what actions they can perform.</p> <p>Models</p> <ul> <li>RBAC: Role-Based Access Control</li> <li>ABAC: Attribute-Based Access Control</li> <li>ACL: Access Control Lists</li> </ul>"},{"location":"fundamentals/security/#encryption","title":"Encryption","text":""},{"location":"fundamentals/security/#symmetric-encryption","title":"Symmetric Encryption","text":"<p>Uses the same key for both encryption and decryption.</p> <p>Common Algorithms</p> <ul> <li>AES (Advanced Encryption Standard)</li> <li>DES (Data Encryption Standard)</li> <li>3DES (Triple DES)</li> </ul>"},{"location":"fundamentals/security/#asymmetric-encryption","title":"Asymmetric Encryption","text":"<p>Uses a pair of keys: public key for encryption and private key for decryption.</p> <p>Use Cases</p> <ul> <li>SSL/TLS for secure web communication</li> <li>Digital signatures</li> <li>Key exchange</li> </ul>"},{"location":"fundamentals/security/#security-protocols","title":"Security Protocols","text":""},{"location":"fundamentals/security/#tlsssl","title":"TLS/SSL","text":"<p>Cryptographic protocols that provide secure communication over a computer network.</p> <p>Best Practices</p> <ul> <li>Use TLS 1.2 or higher</li> <li>Implement perfect forward secrecy</li> <li>Regular certificate rotation</li> </ul>"},{"location":"fundamentals/security/#oauth-20","title":"OAuth 2.0","text":"<p>Authorization framework that enables applications to obtain limited access to user accounts.</p> <p>Grant Types</p> <ul> <li>Authorization Code</li> <li>Implicit</li> <li>Client Credentials</li> <li>Resource Owner Password Credentials</li> </ul>"},{"location":"fundamentals/security/#security-headers","title":"Security Headers","text":""},{"location":"fundamentals/security/#http-security-headers","title":"HTTP Security Headers","text":"<p>Headers that help protect against common web vulnerabilities.</p> <p>Important Headers</p> <ul> <li>Content-Security-Policy: Controls resources browser can load</li> <li>X-Frame-Options: Prevents clickjacking</li> <li>X-Content-Type-Options: Prevents MIME type sniffing</li> <li>Strict-Transport-Security: Enforces HTTPS</li> </ul>"},{"location":"fundamentals/security/#common-vulnerabilities","title":"Common Vulnerabilities","text":""},{"location":"fundamentals/security/#owasp-top-10","title":"OWASP Top 10","text":"<p>Most critical web application security risks.</p> <p>Key Risks</p> <ul> <li>Injection attacks (SQL, NoSQL, OS)</li> <li>Broken Authentication</li> <li>Sensitive Data Exposure</li> <li>XML External Entities (XXE)</li> <li>Broken Access Control</li> <li>Security Misconfiguration</li> <li>Cross-Site Scripting (XSS)</li> <li>Insecure Deserialization</li> <li>Using Components with Known Vulnerabilities</li> <li>Insufficient Logging &amp; Monitoring</li> </ul>"},{"location":"fundamentals/security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"fundamentals/security/#data-protection","title":"Data Protection","text":"<p>Strategies for protecting sensitive data.</p> <p>Recommendations</p> <ul> <li>Encrypt data at rest and in transit</li> <li>Implement proper key management</li> <li>Regular security audits</li> <li>Data minimization principles</li> </ul>"},{"location":"fundamentals/security/#api-security","title":"API Security","text":"<p>Measures to secure API endpoints.</p> <p>Essential Practices</p> <ul> <li>Rate limiting</li> <li>Input validation</li> <li>Proper error handling</li> <li>API versioning</li> <li>Regular security testing</li> </ul>"},{"location":"fundamentals/server-infrastructure/","title":"Server Infrastructure","text":"<p>We often categorize servers by their primary function rather than their underlying technology.</p>"},{"location":"fundamentals/server-infrastructure/#infrastructure-components","title":"Infrastructure Components","text":""},{"location":"fundamentals/server-infrastructure/#web-server","title":"Web Server","text":"<p>A server with a specialized software that handles HTTP requests from clients (typically browsers). It directly serves static content (HTML, CSS, JavaScript, images), forwards requests for dynamic content to backend servers for processing, and returns appropriate responses to the client.</p> <p>Primary Function</p> <ul> <li>Focus on serving web content, handling HTTP protocols, and routing requests</li> </ul> <p>Examples</p> <ul> <li>IIS, Nginx, Apache HTTP Server</li> </ul>"},{"location":"fundamentals/server-infrastructure/#reverse-proxy","title":"Reverse Proxy","text":"<p>A server with a specialized software that sits between client devices and backend servers, intercepting client requests and forwarding them to appropriate backend servers while providing security, SSL termination, and caching.</p> <p>Primary Function</p> <ul> <li>Focus on request forwarding, content caching, and security</li> </ul> <p>Examples</p> <ul> <li>Nginx, IIS with Application Request Routing (ARR), Apache with mod_proxy</li> </ul>"},{"location":"fundamentals/server-infrastructure/#load-balancer","title":"Load Balancer","text":"<p>A server with a specialized software that distributes incoming client requests across multiple servers to ensure high availability, avoid traffic overload, prevent single points of failure, and enable horizontal scaling.</p> <p>Primary Function</p> <ul> <li>Focus on traffic distribution and high availability</li> </ul> <p>Examples</p> <ul> <li>Load Balancing Software: Microsoft Network Load Balancing (NLB), Nginx, HAProxy</li> <li>Cloud-based Services: AWS Elastic Load Balancing, Azure Load Balancer</li> </ul>"},{"location":"fundamentals/server-infrastructure/#api-gateway","title":"API Gateway","text":"<p>A server with a specialized software that acts as a single entry point for client applications to access multiple backend services and APIs. It serves as a reverse proxy for API requests while providing additional functionality such as request routing, authentication, and monitoring.</p> <p>Primary Function</p> <ul> <li>Focus on API traffic management, security, and request coordination across multiple services</li> </ul> <p>Examples</p> <ul> <li>Cloud-based Services: Azure API Management, Amazon API Gateway</li> <li>Software: Kong, Apigee, Tyk</li> </ul>"},{"location":"fundamentals/server-infrastructure/#cdn-content-delivery-network","title":"CDN (Content Delivery Network)","text":"<p>A distributed network of servers that caches and delivers web content from the server closest to users, improving performance and user experience.</p> <p>Key Characteristic</p> <ul> <li>Distributed globally to optimize content delivery</li> </ul> <p>Examples</p> <ul> <li>CloudFlare, Akamai, Fastly</li> </ul>"},{"location":"fundamentals/server-infrastructure/#server-deployment-models","title":"Server Deployment Models","text":""},{"location":"fundamentals/server-infrastructure/#physical-servers","title":"Physical Servers","text":"<p>Traditional deployment using dedicated hardware.</p> <p>Characteristics</p> <ul> <li>Full control over hardware and infrastructure</li> <li>Higher upfront costs and maintenance overhead</li> <li>Fixed capacity with manual scaling</li> <li>Requires physical maintenance and datacenter management</li> </ul>"},{"location":"fundamentals/server-infrastructure/#virtual-machines-vms","title":"Virtual Machines (VMs)","text":"<p>Indenpendent computer environments created using software (1) on a single physical machine, allowing multiple \"virtual computers\" to run separately while sharing the same hardware resources. Each VM has its own operating system and appears to applications as a standalone computer.</p> <ol> <li>Hypervisor: A virtualization software</li> </ol> <p>Characteristics</p> <ul> <li>Resource isolation through hypervisors</li> <li>Support for multiple operating systems</li> <li>Better resource utilization than physical servers</li> <li>More flexible scaling and provisioning</li> </ul>"},{"location":"fundamentals/server-infrastructure/#containers","title":"Containers","text":"<p>Lightweight, standalone executable packages including application code and dependencies.</p> <p>Characteristics</p> <ul> <li>Process-level isolation (shares OS kernel)</li> <li>Consistent environments across development and production</li> <li>Fast startup and deployment times</li> <li>Highly efficient resource utilization</li> <li>Orchestration through tools like Kubernetes</li> </ul>"},{"location":"fundamentals/server-infrastructure/#cloud-based-services","title":"Cloud-based Services","text":"<p>Infrastructure hosted and managed by cloud service providers with various abstraction levels (Cloud computing models).</p> <p>Characteristics</p> <ul> <li>Remote infrastructure management</li> <li>Pay-as-you-go or subscription-based pricing</li> <li>Elastic scaling capabilities</li> <li>Managed services reducing operational overhead</li> <li>Global availability and region-specific deployments</li> <li>Shared responsibility security model</li> </ul>"},{"location":"fundamentals/server-infrastructure/#iaas-infrastructure-as-a-service","title":"IaaS (Infrastructure as a Service)","text":"<p>A cloud computing model where cloud provider offers virtual infrastucture resources (servers, VMs, storage, networking) over the internet on a pay-as-you-go basis.</p> <p>Characteristics</p> <ul> <li>You manage the operating systems, middleware, and applications</li> <li>The provider manages the hardware infrastructure</li> <li>Requires the most management from your side</li> <li>Virtualized computing resources</li> <li>Self-service provisioning</li> </ul> <p>Example</p> <ul> <li>AWS EC2</li> <li>Azure Virtual Machines</li> <li>Google Compute Engine</li> </ul>"},{"location":"fundamentals/server-infrastructure/#paas-platform-as-a-service","title":"PaaS (Platform as a Service)","text":"<p>A cloud computing model that provides a platform enviroment allowing customers to develop, run, and manage applications.</p> <p>Characteristics</p> <ul> <li>You focus on application development</li> <li>The provider manages the runtime, operating system, and underlying infrastructure</li> <li>Simplifies development and deployment</li> <li>Built-in scalability and high availability</li> <li>Reduced operational management</li> </ul> <p>Example</p> <ul> <li>Azure App Service</li> <li>Google App Engine</li> <li>Heroku</li> </ul>"},{"location":"fundamentals/server-infrastructure/#serverlessfaas-function-as-a-service","title":"Serverless/FaaS (Function as a Service)","text":"<p>A cloud computing model that allows developers to build, deploy, and execute individual functions (or microservices) without managing the underlying infrastructure.</p> <p>Characteristics</p> <ul> <li>You pay only for execution time (not idle capacity)</li> <li>The provider fully manages starting and stopping virtual machines (No server management required)</li> <li>Automatic scaling based on demand</li> <li>Event-driven architecture</li> <li>Stateless execution model</li> </ul> <p>Example</p> <ul> <li>AWS Lambda</li> <li>Azure Functions</li> <li>Google Cloud Functions</li> <li>Cloudflare Workers</li> </ul>"},{"location":"fundamentals/server-infrastructure/#saas-software-as-a-service","title":"SaaS (Software as a Service)","text":"<p>A computing model where cloud providers host, manage, and deliver applications to customers over the internet.</p> <p>Characteristics</p> <ul> <li>Complete application delivered as a service</li> <li>No local installation or maintenance required</li> <li>Typically subscription-based pricing</li> <li>Provider manages everything (infrastructure, platform, application)</li> </ul> <p>Example</p> <ul> <li>Microsoft 365</li> <li>Salesforce</li> <li>Google Workspace</li> </ul>"},{"location":"fundamentals/software-architecture/","title":"Software Architecture &amp; Design","text":""},{"location":"fundamentals/software-architecture/#software-architecture-patterns","title":"Software Architecture Patterns","text":""},{"location":"fundamentals/software-architecture/#monolithic-architecture","title":"Monolithic Architecture","text":"<p>A software design pattern where an application is built as a single, unified codebase with tightly coupled components (user interface, business logic, data access).</p> <pre><code>flowchart TD\n    subgraph \"Monolithic Application\"\n        UI[User Interface Layer]\n        BL[Business Logic Layer]\n        DAL[Data Access Layer]\n        DB[(Database)]\n\n        Client[Client] --&gt;|Request| UI\n        UI --&gt;|Process| BL\n        BL --&gt;|Store/Retrieve| DAL\n        DAL --&gt;|Query| DB\n    end\n\n    note[Single Deployable Unit: All components &lt;br&gt; are packaged and deployed together]\n    style note fill:#f9f,stroke:#333,stroke-width:1px</code></pre> <p>Pros</p> <ul> <li>Simplicity</li> <li>Easier to debug</li> <li>Faster initial development</li> </ul> <p>Cons</p> <ul> <li>Harder to scale</li> <li>Can become complex and hard to maintain</li> <li>Team coordination challenges</li> </ul>"},{"location":"fundamentals/software-architecture/#microservices-architecture","title":"Microservices Architecture","text":"<p>A software design pattern where an application is built as a collection of small, independent services that communicate over a network. Each microservice focuses on a specific business function and maintains its own data.</p> <pre><code>flowchart TD\nClient[Client] --&gt; API[API Gateway]\n\n    subgraph \"Microservice 1: User Service\"\n        US[User Service] --&gt; UDB[(User DB)]\n    end\n\n    subgraph \"Microservice 2: Order Service\"\n        OS[Order Service] --&gt; ODB[(Order DB)]\n    end\n\n    subgraph \"Microservice 3: Product Service\"\n        PS[Product Service] --&gt; PDB[(Product DB)]\n    end\n\n    subgraph \"Microservice 4: Payment Service\"\n        PAYS[Payment Service] --&gt; PAYDB[(Payment DB)]\n    end\n\n    API --&gt; US\n    API --&gt; OS\n    API --&gt; PS\n    API --&gt; PAYS\n\n    OS --&gt;|Communication| PS\n    OS --&gt;|Communication| PAYS\n\n    note[Independent Services - &lt;br&gt;Each with its own database &lt;br&gt;and deployment pipeline]\n    style note fill:#afd,stroke:#333,stroke-width:1px</code></pre> <p>Pros</p> <ul> <li>Independent scaling</li> <li>Technology flexibility</li> <li>Easier for team collaboration</li> <li>Fault isolation</li> </ul> <p>Cons</p> <ul> <li>Complex to set up and manage</li> <li>Harder to test end-to-end</li> <li>Data consistency challenges</li> <li>Network overhead</li> </ul>"},{"location":"fundamentals/software-architecture/#service-oriented-architecture-soa","title":"Service-Oriented Architecture (SOA)","text":"<p>A software design pattern that focuses on building reusable services to serve multiple applications across an entire organization. These services typically communicate through standardized interfaces or an ESB (Enterprise Service Bus), enabling different applications to use these services regardless of the underlying technologies.</p> <pre><code>flowchart TD\nApp1[Application 1] --&gt; ESB\nApp2[Application 2] --&gt; ESB\nApp3[Application 3] --&gt; ESB\n\n    subgraph \"Enterprise Service Bus (ESB)\"\n        ESB[Enterprise Service Bus]\n    end\n\n    ESB --&gt; S1\n    ESB --&gt; S2\n    ESB --&gt; S3\n    ESB --&gt; S4\n\n    subgraph \"Shared Services\"\n        S1[Customer Service]\n        S2[Product Catalog Service]\n        S3[Order Processing Service]\n        S4[Authentication Service]\n    end\n\n    S1 --&gt; DB1[(Shared Database)]\n    S2 --&gt; DB1\n    S3 --&gt; DB1\n    S4 --&gt; DB2[(Auth Database)]\n\n    note[Business-aligned services &lt;br&gt;with centralized communication &lt;br&gt;through Enterprise Service Bus]\n    style note fill:#ccf,stroke:#333,stroke-width:1px</code></pre> <p>Pros</p> <ul> <li>Reusable services</li> <li>Business-aligned modularity</li> <li>Can integrate legacy systems</li> <li>Standardized interfaces</li> </ul> <p>Cons</p> <ul> <li>Complex to manage</li> <li>Centralized ESB can become a performance bottleneck and single point of failure</li> <li>Often requires significant governance</li> </ul>"},{"location":"fundamentals/software-architecture/#microservices-design-patterns","title":"Microservices Design Patterns","text":""},{"location":"fundamentals/software-architecture/#api-gateway","title":"API Gateway","text":"<p>The API Gateway pattern provides a unified entry point for clients to interact with a system of microservices.</p> <p>Implementation Considerations</p> <p>Should handle cross-cutting concerns like authentication, logging, and request routing</p>"},{"location":"fundamentals/software-architecture/#service-discovery","title":"Service Discovery","text":"<p>Service that enables microservices to find and communicate with each other without hardcoded locations.</p> <p>Implementation Options</p> <ul> <li>Client-side discovery: Services query a registry (e.g., Netflix Eureka)</li> <li>Server-side discovery: Load balancer routes requests (e.g., Kubernetes Service)</li> </ul>"},{"location":"fundamentals/software-architecture/#saga-pattern","title":"Saga Pattern","text":"<p>Sequence of local transactions where each transaction updates data within a single service.</p> <p>Coordination Methods</p> <ul> <li>Choreography: Each service publishes events that trigger other services</li> <li>Orchestration: Central coordinator directs the saga steps</li> </ul>"},{"location":"fundamentals/software-architecture/#sidecar-pattern","title":"Sidecar Pattern","text":"<p>Deploys components of an application as separate processes or containers to provide isolation and encapsulation.</p> <p>Common Uses</p> <ul> <li>Service mesh proxies (Istio, Linkerd)</li> <li>Logging agents</li> <li>Configuration agents</li> </ul>"},{"location":"fundamentals/software-architecture/#cqrs-command-query-responsibility-segregation","title":"CQRS (Command Query Responsibility Segregation)","text":"<p>Pattern that separates read and write operations to optimize performance, scalability, and security.</p> <p>When to Use</p> <ul> <li>When read and write workloads have significantly different performance and scaling requirements</li> </ul>"},{"location":"fundamentals/software-architecture/#event-driven-architecture","title":"Event-Driven Architecture","text":"<p>Design paradigm where components communicate through events, promoting loose coupling and scalability.</p> <p>Implementation Technologies</p> <ul> <li>Kafka</li> <li>RabbitMQ</li> <li>AWS EventBridge</li> <li>Azure Event Grid</li> </ul>"},{"location":"fundamentals/software-architecture/#strangler-pattern","title":"Strangler Pattern","text":"<p>A migration pattern/strategy for incrementally replacing a legacy system by gradually routing functionality to new services.</p> <p>Implementation Steps</p> <ol> <li>Create a facade in front of the legacy system</li> <li>Gradually build new functionality behind the facade</li> <li>Incrementally redirect from legacy to new implementation</li> <li>Remove legacy code when no longer used</li> </ol>"},{"location":"fundamentals/software-architecture/#software-design-approaches","title":"Software Design Approaches","text":""},{"location":"fundamentals/software-architecture/#domain-driven-design-ddd","title":"Domain-Driven Design (DDD)","text":"<p>Software development approach focusing on the core domain and domain logic.</p> <p>Key Concepts</p> <ul> <li>Bounded contexts</li> <li>Ubiquitous language</li> <li>Aggregates</li> <li>Domain events</li> <li>Repositories</li> </ul>"},{"location":"fundamentals/software-architecture/#test-driven-development-tdd","title":"Test-Driven Development (TDD)","text":"<p>Development process where tests are written before code implementation, guiding the design through failing tests that are later made to pass.</p> <p>TDD Cycle</p> <ol> <li>Write a failing test</li> <li>Write minimal code to pass the test</li> <li>Refactor while maintaining passing tests</li> </ol>"},{"location":"fundamentals/software-architecture/#event-sourcing","title":"Event Sourcing","text":"<p>Storing changes to application state as a sequence of events rather than just the current state.</p> <p>Benefits</p> <ul> <li>Complete audit history</li> <li>Time travel (reconstruct past states)</li> <li>Excellent for debugging and analysis</li> </ul>"}]}